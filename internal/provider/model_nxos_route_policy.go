// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports

import (
	"context"
	"fmt"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-nxos"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

type RoutePolicy struct {
	Device          types.String                 `tfsdk:"device"`
	Dn              types.String                 `tfsdk:"id"`
	Ipv4PrefixLists []RoutePolicyIpv4PrefixLists `tfsdk:"ipv4_prefix_lists"`
	RouteMaps       []RoutePolicyRouteMaps       `tfsdk:"route_maps"`
}

type RoutePolicyIpv4PrefixLists struct {
	Name    types.String                        `tfsdk:"name"`
	Entries []RoutePolicyIpv4PrefixListsEntries `tfsdk:"entries"`
}

type RoutePolicyIpv4PrefixListsEntries struct {
	Order     types.Int64  `tfsdk:"order"`
	Action    types.String `tfsdk:"action"`
	Criteria  types.String `tfsdk:"criteria"`
	Prefix    types.String `tfsdk:"prefix"`
	FromRange types.Int64  `tfsdk:"from_range"`
	ToRange   types.Int64  `tfsdk:"to_range"`
}

type RoutePolicyRouteMaps struct {
	Name    types.String                  `tfsdk:"name"`
	Entries []RoutePolicyRouteMapsEntries `tfsdk:"entries"`
}

type RoutePolicyRouteMapsEntries struct {
	Order                    types.Int64                                           `tfsdk:"order"`
	Action                   types.String                                          `tfsdk:"action"`
	MatchRoutePrefixLists    []RoutePolicyRouteMapsEntriesMatchRoutePrefixLists    `tfsdk:"match_route_prefix_lists"`
	Additive                 types.String                                          `tfsdk:"additive"`
	NoCommunity              types.String                                          `tfsdk:"no_community"`
	SetCriteria              types.String                                          `tfsdk:"set_criteria"`
	SetRegularCommunityItems []RoutePolicyRouteMapsEntriesSetRegularCommunityItems `tfsdk:"set_regular_community_items"`
	MatchTags                []RoutePolicyRouteMapsEntriesMatchTags                `tfsdk:"match_tags"`
}

type RoutePolicyRouteMapsEntriesMatchRoutePrefixLists struct {
	PrefixListDn types.String `tfsdk:"prefix_list_dn"`
}

type RoutePolicyRouteMapsEntriesSetRegularCommunityItems struct {
	Community types.String `tfsdk:"community"`
}

type RoutePolicyRouteMapsEntriesMatchTags struct {
	Tag types.Int64 `tfsdk:"tag"`
}

type RoutePolicyIdentity struct {
	Device types.String `tfsdk:"device"`
}

func (data *RoutePolicyIdentity) toIdentity(ctx context.Context, plan *RoutePolicy) {
	if plan.Device.IsNull() {
		data.Device = types.StringValue("")
	} else {
		data.Device = plan.Device
	}
}

func (data *RoutePolicy) fromIdentity(ctx context.Context, identity *RoutePolicyIdentity) {
	if identity.Device.ValueString() == "" {
		data.Device = types.StringNull()
	} else {
		data.Device = identity.Device
	}
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data RoutePolicy) getDn() string {
	return "sys/rpm"
}

func (data RoutePolicyIpv4PrefixLists) getRn() string {
	return fmt.Sprintf("pfxlistv4-[%s]", data.Name.ValueString())
}

func (data RoutePolicyIpv4PrefixListsEntries) getRn() string {
	return fmt.Sprintf("ent-%v", data.Order.ValueInt64())
}

func (data RoutePolicyRouteMaps) getRn() string {
	return fmt.Sprintf("rtmap-[%s]", data.Name.ValueString())
}

func (data RoutePolicyRouteMapsEntries) getRn() string {
	return fmt.Sprintf("ent-%v", data.Order.ValueInt64())
}

func (data RoutePolicyRouteMapsEntriesMatchRoutePrefixLists) getRn() string {
	return fmt.Sprintf("rsrtDstAtt-[%s]", data.PrefixListDn.ValueString())
}

func (data RoutePolicyRouteMapsEntriesSetRegularCommunityItems) getRn() string {
	return fmt.Sprintf("item-%s", data.Community.ValueString())
}

func (data RoutePolicyRouteMapsEntriesMatchTags) getRn() string {
	return fmt.Sprintf("mrttag-%v", data.Tag.ValueInt64())
}

func (data RoutePolicy) getClassName() string {
	return "rpmEntity"
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data RoutePolicy) toBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	var attrs string
	childrenPath := data.getClassName() + ".children"
	for _, child := range data.Ipv4PrefixLists {
		attrs = "{}"
		if (!child.Name.IsUnknown() && !child.Name.IsNull()) || false {
			attrs, _ = sjson.Set(attrs, "name", child.Name.ValueString())
		}
		body, _ = sjson.SetRaw(body, childrenPath+".-1.rtpfxRuleV4.attributes", attrs)
		{
			nestedIndex := len(gjson.Get(body, childrenPath).Array()) - 1
			nestedChildrenPath := childrenPath + "." + strconv.Itoa(nestedIndex) + ".rtpfxRuleV4.children"
			for _, child := range child.Entries {
				attrs = "{}"
				if (!child.Order.IsUnknown() && !child.Order.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "order", strconv.FormatInt(child.Order.ValueInt64(), 10))
				}
				if (!child.Action.IsUnknown() && !child.Action.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "action", child.Action.ValueString())
				}
				if (!child.Criteria.IsUnknown() && !child.Criteria.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "criteria", child.Criteria.ValueString())
				}
				if (!child.Prefix.IsUnknown() && !child.Prefix.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "pfx", child.Prefix.ValueString())
				}
				if (!child.FromRange.IsUnknown() && !child.FromRange.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "fromPfxLen", strconv.FormatInt(child.FromRange.ValueInt64(), 10))
				}
				if (!child.ToRange.IsUnknown() && !child.ToRange.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "toPfxLen", strconv.FormatInt(child.ToRange.ValueInt64(), 10))
				}
				body, _ = sjson.SetRaw(body, nestedChildrenPath+".-1.rtpfxEntry.attributes", attrs)
			}
		}
	}
	for _, child := range data.RouteMaps {
		attrs = "{}"
		if (!child.Name.IsUnknown() && !child.Name.IsNull()) || false {
			attrs, _ = sjson.Set(attrs, "name", child.Name.ValueString())
		}
		body, _ = sjson.SetRaw(body, childrenPath+".-1.rtmapRule.attributes", attrs)
		{
			nestedIndex := len(gjson.Get(body, childrenPath).Array()) - 1
			nestedChildrenPath := childrenPath + "." + strconv.Itoa(nestedIndex) + ".rtmapRule.children"
			for _, child := range child.Entries {
				attrs = "{}"
				if (!child.Order.IsUnknown() && !child.Order.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "order", strconv.FormatInt(child.Order.ValueInt64(), 10))
				}
				if (!child.Action.IsUnknown() && !child.Action.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "action", child.Action.ValueString())
				}
				body, _ = sjson.SetRaw(body, nestedChildrenPath+".-1.rtmapEntry.attributes", attrs)
				{
					nestedIndex := len(gjson.Get(body, nestedChildrenPath).Array()) - 1
					nestedChildrenPath := nestedChildrenPath + "." + strconv.Itoa(nestedIndex) + ".rtmapEntry.children"
					{
						childIndex := len(gjson.Get(body, nestedChildrenPath).Array())
						childBodyPath := nestedChildrenPath + "." + strconv.Itoa(childIndex) + ".rtmapMatchRtDst"
						attrs = "{}"
						body, _ = sjson.SetRaw(body, childBodyPath+".attributes", attrs)
						nestedChildrenPath := childBodyPath + ".children"
						for _, child := range child.MatchRoutePrefixLists {
							attrs = "{}"
							if (!child.PrefixListDn.IsUnknown() && !child.PrefixListDn.IsNull()) || false {
								attrs, _ = sjson.Set(attrs, "tDn", child.PrefixListDn.ValueString())
							}
							body, _ = sjson.SetRaw(body, nestedChildrenPath+".-1.rtmapRsRtDstAtt.attributes", attrs)
						}
					}
					{
						childIndex := len(gjson.Get(body, nestedChildrenPath).Array())
						childBodyPath := nestedChildrenPath + "." + strconv.Itoa(childIndex) + ".rtmapSetRegComm"
						attrs = "{}"
						if (!child.Additive.IsUnknown() && !child.Additive.IsNull()) || false {
							attrs, _ = sjson.Set(attrs, "additive", child.Additive.ValueString())
						}
						if (!child.NoCommunity.IsUnknown() && !child.NoCommunity.IsNull()) || false {
							attrs, _ = sjson.Set(attrs, "noCommAttr", child.NoCommunity.ValueString())
						}
						if (!child.SetCriteria.IsUnknown() && !child.SetCriteria.IsNull()) || false {
							attrs, _ = sjson.Set(attrs, "setCriteria", child.SetCriteria.ValueString())
						}
						body, _ = sjson.SetRaw(body, childBodyPath+".attributes", attrs)
						nestedChildrenPath := childBodyPath + ".children"
						for _, child := range child.SetRegularCommunityItems {
							attrs = "{}"
							if (!child.Community.IsUnknown() && !child.Community.IsNull()) || false {
								attrs, _ = sjson.Set(attrs, "community", child.Community.ValueString())
							}
							body, _ = sjson.SetRaw(body, nestedChildrenPath+".-1.rtregcomItem.attributes", attrs)
						}
					}
					for _, child := range child.MatchTags {
						attrs = "{}"
						if (!child.Tag.IsUnknown() && !child.Tag.IsNull()) || false {
							attrs, _ = sjson.Set(attrs, "tag", strconv.FormatInt(child.Tag.ValueInt64(), 10))
						}
						body, _ = sjson.SetRaw(body, nestedChildrenPath+".-1.rtmapMatchRtTag.attributes", attrs)
					}
				}
			}
		}
	}

	return nxos.Body{body}
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *RoutePolicy) fromBody(res gjson.Result) {
	res.Get(data.getClassName() + ".children").ForEach(
		func(_, v gjson.Result) bool {
			v.ForEach(
				func(classname, value gjson.Result) bool {
					if classname.String() == "rtpfxRuleV4" {
						var child RoutePolicyIpv4PrefixLists
						child.Name = types.StringValue(value.Get("attributes.name").String())
						value.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								nestedV.ForEach(
									func(nestedClassname, nestedValue gjson.Result) bool {
										if nestedClassname.String() == "rtpfxEntry" {
											var nestedChildrtpfxEntry RoutePolicyIpv4PrefixListsEntries
											nestedChildrtpfxEntry.Order = types.Int64Value(nestedValue.Get("attributes.order").Int())
											nestedChildrtpfxEntry.Action = types.StringValue(nestedValue.Get("attributes.action").String())
											nestedChildrtpfxEntry.Criteria = types.StringValue(nestedValue.Get("attributes.criteria").String())
											nestedChildrtpfxEntry.Prefix = types.StringValue(nestedValue.Get("attributes.pfx").String())
											nestedChildrtpfxEntry.FromRange = types.Int64Value(nestedValue.Get("attributes.fromPfxLen").Int())
											nestedChildrtpfxEntry.ToRange = types.Int64Value(nestedValue.Get("attributes.toPfxLen").Int())
											child.Entries = append(child.Entries, nestedChildrtpfxEntry)
										}
										return true
									},
								)
								return true
							},
						)
						data.Ipv4PrefixLists = append(data.Ipv4PrefixLists, child)
					}
					return true
				},
			)
			return true
		},
	)
	res.Get(data.getClassName() + ".children").ForEach(
		func(_, v gjson.Result) bool {
			v.ForEach(
				func(classname, value gjson.Result) bool {
					if classname.String() == "rtmapRule" {
						var child RoutePolicyRouteMaps
						child.Name = types.StringValue(value.Get("attributes.name").String())
						value.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								nestedV.ForEach(
									func(nestedClassname, nestedValue gjson.Result) bool {
										if nestedClassname.String() == "rtmapEntry" {
											var nestedChildrtmapEntry RoutePolicyRouteMapsEntries
											nestedChildrtmapEntry.Order = types.Int64Value(nestedValue.Get("attributes.order").Int())
											nestedChildrtmapEntry.Action = types.StringValue(nestedValue.Get("attributes.action").String())
											{
												var rrtmapMatchRtDst gjson.Result
												nestedValue.Get("children").ForEach(
													func(_, nestedV gjson.Result) bool {
														key := nestedV.Get("rtmapMatchRtDst.attributes.rn").String()
														if key == "mrtdst" {
															rrtmapMatchRtDst = nestedV
															return false
														}
														return true
													},
												)
												rrtmapMatchRtDst.Get("rtmapMatchRtDst").Get("children").ForEach(
													func(_, nestedV gjson.Result) bool {
														nestedV.ForEach(
															func(nestedClassname, nestedValue gjson.Result) bool {
																if nestedClassname.String() == "rtmapRsRtDstAtt" {
																	var nestedChildrtmapRsRtDstAtt RoutePolicyRouteMapsEntriesMatchRoutePrefixLists
																	nestedChildrtmapRsRtDstAtt.PrefixListDn = types.StringValue(nestedValue.Get("attributes.tDn").String())
																	nestedChildrtmapEntry.MatchRoutePrefixLists = append(nestedChildrtmapEntry.MatchRoutePrefixLists, nestedChildrtmapRsRtDstAtt)
																}
																return true
															},
														)
														return true
													},
												)
											}
											{
												var rrtmapSetRegComm gjson.Result
												nestedValue.Get("children").ForEach(
													func(_, nestedV gjson.Result) bool {
														key := nestedV.Get("rtmapSetRegComm.attributes.rn").String()
														if key == "sregcomm" {
															rrtmapSetRegComm = nestedV
															return false
														}
														return true
													},
												)
												nestedChildrtmapEntry.Additive = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.additive").String())
												nestedChildrtmapEntry.NoCommunity = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.noCommAttr").String())
												nestedChildrtmapEntry.SetCriteria = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.setCriteria").String())
												rrtmapSetRegComm.Get("rtmapSetRegComm").Get("children").ForEach(
													func(_, nestedV gjson.Result) bool {
														nestedV.ForEach(
															func(nestedClassname, nestedValue gjson.Result) bool {
																if nestedClassname.String() == "rtregcomItem" {
																	var nestedChildrtregcomItem RoutePolicyRouteMapsEntriesSetRegularCommunityItems
																	nestedChildrtregcomItem.Community = types.StringValue(nestedValue.Get("attributes.community").String())
																	nestedChildrtmapEntry.SetRegularCommunityItems = append(nestedChildrtmapEntry.SetRegularCommunityItems, nestedChildrtregcomItem)
																}
																return true
															},
														)
														return true
													},
												)
											}
											nestedValue.Get("children").ForEach(
												func(_, nestedV gjson.Result) bool {
													nestedV.ForEach(
														func(nestedClassname, nestedValue gjson.Result) bool {
															if nestedClassname.String() == "rtmapMatchRtTag" {
																var nestedChildrtmapMatchRtTag RoutePolicyRouteMapsEntriesMatchTags
																nestedChildrtmapMatchRtTag.Tag = types.Int64Value(nestedValue.Get("attributes.tag").Int())
																nestedChildrtmapEntry.MatchTags = append(nestedChildrtmapEntry.MatchTags, nestedChildrtmapMatchRtTag)
															}
															return true
														},
													)
													return true
												},
											)
											child.Entries = append(child.Entries, nestedChildrtmapEntry)
										}
										return true
									},
								)
								return true
							},
						)
						data.RouteMaps = append(data.RouteMaps, child)
					}
					return true
				},
			)
			return true
		},
	)
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *RoutePolicy) updateFromBody(res gjson.Result) {
	for c := range data.Ipv4PrefixLists {
		var rrtpfxRuleV4 gjson.Result
		res.Get(data.getClassName() + ".children").ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("rtpfxRuleV4.attributes.rn").String()
				if key == data.Ipv4PrefixLists[c].getRn() {
					rrtpfxRuleV4 = v
					return false
				}
				return true
			},
		)
		if !data.Ipv4PrefixLists[c].Name.IsNull() {
			data.Ipv4PrefixLists[c].Name = types.StringValue(rrtpfxRuleV4.Get("rtpfxRuleV4.attributes.name").String())
		} else {
			data.Ipv4PrefixLists[c].Name = types.StringNull()
		}
		for nc := range data.Ipv4PrefixLists[c].Entries {
			var rrtpfxEntry gjson.Result
			rrtpfxRuleV4.Get("rtpfxRuleV4.children").ForEach(
				func(_, v gjson.Result) bool {
					key := v.Get("rtpfxEntry.attributes.rn").String()
					if key == data.Ipv4PrefixLists[c].Entries[nc].getRn() {
						rrtpfxEntry = v
						return false
					}
					return true
				},
			)
			if !data.Ipv4PrefixLists[c].Entries[nc].Order.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].Order = types.Int64Value(rrtpfxEntry.Get("rtpfxEntry.attributes.order").Int())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].Order = types.Int64Null()
			}
			if !data.Ipv4PrefixLists[c].Entries[nc].Action.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].Action = types.StringValue(rrtpfxEntry.Get("rtpfxEntry.attributes.action").String())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].Action = types.StringNull()
			}
			if !data.Ipv4PrefixLists[c].Entries[nc].Criteria.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].Criteria = types.StringValue(rrtpfxEntry.Get("rtpfxEntry.attributes.criteria").String())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].Criteria = types.StringNull()
			}
			if !data.Ipv4PrefixLists[c].Entries[nc].Prefix.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].Prefix = types.StringValue(rrtpfxEntry.Get("rtpfxEntry.attributes.pfx").String())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].Prefix = types.StringNull()
			}
			if !data.Ipv4PrefixLists[c].Entries[nc].FromRange.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].FromRange = types.Int64Value(rrtpfxEntry.Get("rtpfxEntry.attributes.fromPfxLen").Int())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].FromRange = types.Int64Null()
			}
			if !data.Ipv4PrefixLists[c].Entries[nc].ToRange.IsNull() {
				data.Ipv4PrefixLists[c].Entries[nc].ToRange = types.Int64Value(rrtpfxEntry.Get("rtpfxEntry.attributes.toPfxLen").Int())
			} else {
				data.Ipv4PrefixLists[c].Entries[nc].ToRange = types.Int64Null()
			}
		}
	}
	for c := range data.RouteMaps {
		var rrtmapRule gjson.Result
		res.Get(data.getClassName() + ".children").ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("rtmapRule.attributes.rn").String()
				if key == data.RouteMaps[c].getRn() {
					rrtmapRule = v
					return false
				}
				return true
			},
		)
		if !data.RouteMaps[c].Name.IsNull() {
			data.RouteMaps[c].Name = types.StringValue(rrtmapRule.Get("rtmapRule.attributes.name").String())
		} else {
			data.RouteMaps[c].Name = types.StringNull()
		}
		for nc := range data.RouteMaps[c].Entries {
			var rrtmapEntry gjson.Result
			rrtmapRule.Get("rtmapRule.children").ForEach(
				func(_, v gjson.Result) bool {
					key := v.Get("rtmapEntry.attributes.rn").String()
					if key == data.RouteMaps[c].Entries[nc].getRn() {
						rrtmapEntry = v
						return false
					}
					return true
				},
			)
			if !data.RouteMaps[c].Entries[nc].Order.IsNull() {
				data.RouteMaps[c].Entries[nc].Order = types.Int64Value(rrtmapEntry.Get("rtmapEntry.attributes.order").Int())
			} else {
				data.RouteMaps[c].Entries[nc].Order = types.Int64Null()
			}
			if !data.RouteMaps[c].Entries[nc].Action.IsNull() {
				data.RouteMaps[c].Entries[nc].Action = types.StringValue(rrtmapEntry.Get("rtmapEntry.attributes.action").String())
			} else {
				data.RouteMaps[c].Entries[nc].Action = types.StringNull()
			}
			{
				var rrtmapMatchRtDst gjson.Result
				rrtmapEntry.Get("rtmapEntry.children").ForEach(
					func(_, v gjson.Result) bool {
						key := v.Get("rtmapMatchRtDst.attributes.rn").String()
						if key == "mrtdst" {
							rrtmapMatchRtDst = v
							return false
						}
						return true
					},
				)
				for nc_ := range data.RouteMaps[c].Entries[nc].MatchRoutePrefixLists {
					var rrtmapRsRtDstAtt gjson.Result
					rrtmapMatchRtDst.Get("rtmapMatchRtDst.children").ForEach(
						func(_, v gjson.Result) bool {
							key := v.Get("rtmapRsRtDstAtt.attributes.rn").String()
							if key == data.RouteMaps[c].Entries[nc].MatchRoutePrefixLists[nc_].getRn() {
								rrtmapRsRtDstAtt = v
								return false
							}
							return true
						},
					)
					if !data.RouteMaps[c].Entries[nc].MatchRoutePrefixLists[nc_].PrefixListDn.IsNull() {
						data.RouteMaps[c].Entries[nc].MatchRoutePrefixLists[nc_].PrefixListDn = types.StringValue(rrtmapRsRtDstAtt.Get("rtmapRsRtDstAtt.attributes.tDn").String())
					} else {
						data.RouteMaps[c].Entries[nc].MatchRoutePrefixLists[nc_].PrefixListDn = types.StringNull()
					}
				}
			}
			{
				var rrtmapSetRegComm gjson.Result
				rrtmapEntry.Get("rtmapEntry.children").ForEach(
					func(_, v gjson.Result) bool {
						key := v.Get("rtmapSetRegComm.attributes.rn").String()
						if key == "sregcomm" {
							rrtmapSetRegComm = v
							return false
						}
						return true
					},
				)
				if !data.RouteMaps[c].Entries[nc].Additive.IsNull() {
					data.RouteMaps[c].Entries[nc].Additive = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.additive").String())
				} else {
					data.RouteMaps[c].Entries[nc].Additive = types.StringNull()
				}
				if !data.RouteMaps[c].Entries[nc].NoCommunity.IsNull() {
					data.RouteMaps[c].Entries[nc].NoCommunity = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.noCommAttr").String())
				} else {
					data.RouteMaps[c].Entries[nc].NoCommunity = types.StringNull()
				}
				if !data.RouteMaps[c].Entries[nc].SetCriteria.IsNull() {
					data.RouteMaps[c].Entries[nc].SetCriteria = types.StringValue(rrtmapSetRegComm.Get("rtmapSetRegComm.attributes.setCriteria").String())
				} else {
					data.RouteMaps[c].Entries[nc].SetCriteria = types.StringNull()
				}
				for nc_ := range data.RouteMaps[c].Entries[nc].SetRegularCommunityItems {
					var rrtregcomItem gjson.Result
					rrtmapSetRegComm.Get("rtmapSetRegComm.children").ForEach(
						func(_, v gjson.Result) bool {
							key := v.Get("rtregcomItem.attributes.rn").String()
							if key == data.RouteMaps[c].Entries[nc].SetRegularCommunityItems[nc_].getRn() {
								rrtregcomItem = v
								return false
							}
							return true
						},
					)
					if !data.RouteMaps[c].Entries[nc].SetRegularCommunityItems[nc_].Community.IsNull() {
						data.RouteMaps[c].Entries[nc].SetRegularCommunityItems[nc_].Community = types.StringValue(rrtregcomItem.Get("rtregcomItem.attributes.community").String())
					} else {
						data.RouteMaps[c].Entries[nc].SetRegularCommunityItems[nc_].Community = types.StringNull()
					}
				}
			}
			for nc_ := range data.RouteMaps[c].Entries[nc].MatchTags {
				var rrtmapMatchRtTag gjson.Result
				rrtmapEntry.Get("rtmapEntry.children").ForEach(
					func(_, v gjson.Result) bool {
						key := v.Get("rtmapMatchRtTag.attributes.rn").String()
						if key == data.RouteMaps[c].Entries[nc].MatchTags[nc_].getRn() {
							rrtmapMatchRtTag = v
							return false
						}
						return true
					},
				)
				if !data.RouteMaps[c].Entries[nc].MatchTags[nc_].Tag.IsNull() {
					data.RouteMaps[c].Entries[nc].MatchTags[nc_].Tag = types.Int64Value(rrtmapMatchRtTag.Get("rtmapMatchRtTag.attributes.tag").Int())
				} else {
					data.RouteMaps[c].Entries[nc].MatchTags[nc_].Tag = types.Int64Null()
				}
			}
		}
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin toDeleteBody

func (data RoutePolicy) toDeleteBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes.status", "deleted")

	return nxos.Body{body}
}

func (data RoutePolicy) toBodyWithDeletes(ctx context.Context, state RoutePolicy) nxos.Body {
	body := data.toBody()
	bodyPath := data.getClassName() + ".children"
	_ = bodyPath
	for _, stateChild := range state.Ipv4PrefixLists {
		found := false
		for _, planChild := range data.Ipv4PrefixLists {
			if stateChild.Name == planChild.Name {
				found = true
				break
			}
		}
		if !found {
			deleteBody := ""
			deleteBody, _ = sjson.Set(deleteBody, "rtpfxRuleV4.attributes.rn", stateChild.getRn())
			deleteBody, _ = sjson.Set(deleteBody, "rtpfxRuleV4.attributes.status", "deleted")
			body.Str, _ = sjson.SetRaw(body.Str, bodyPath+".-1", deleteBody)
		}
	}
	for di := range state.Ipv4PrefixLists {
		for pdi := range data.Ipv4PrefixLists {
			if state.Ipv4PrefixLists[di].Name == data.Ipv4PrefixLists[pdi].Name {
				matchBodyPathdi := ""
				for mi, mv := range gjson.Get(body.Str, bodyPath).Array() {
					if mv.Get("rtpfxRuleV4.attributes.rn").String() == state.Ipv4PrefixLists[di].getRn() {
						matchBodyPathdi = bodyPath + "." + strconv.Itoa(mi) + ".rtpfxRuleV4.children"
						break
					}
				}
				if matchBodyPathdi == "" {
					break
				}
				for _, stateChild := range state.Ipv4PrefixLists[di].Entries {
					found := false
					for _, planChild := range data.Ipv4PrefixLists[pdi].Entries {
						if stateChild.Order == planChild.Order {
							found = true
							break
						}
					}
					if !found {
						deleteBody := ""
						deleteBody, _ = sjson.Set(deleteBody, "rtpfxEntry.attributes.rn", stateChild.getRn())
						deleteBody, _ = sjson.Set(deleteBody, "rtpfxEntry.attributes.status", "deleted")
						body.Str, _ = sjson.SetRaw(body.Str, matchBodyPathdi+".-1", deleteBody)
					}
				}
				break
			}
		}
	}
	for _, stateChild := range state.RouteMaps {
		found := false
		for _, planChild := range data.RouteMaps {
			if stateChild.Name == planChild.Name {
				found = true
				break
			}
		}
		if !found {
			deleteBody := ""
			deleteBody, _ = sjson.Set(deleteBody, "rtmapRule.attributes.rn", stateChild.getRn())
			deleteBody, _ = sjson.Set(deleteBody, "rtmapRule.attributes.status", "deleted")
			body.Str, _ = sjson.SetRaw(body.Str, bodyPath+".-1", deleteBody)
		}
	}
	for di := range state.RouteMaps {
		for pdi := range data.RouteMaps {
			if state.RouteMaps[di].Name == data.RouteMaps[pdi].Name {
				matchBodyPathdi := ""
				for mi, mv := range gjson.Get(body.Str, bodyPath).Array() {
					if mv.Get("rtmapRule.attributes.rn").String() == state.RouteMaps[di].getRn() {
						matchBodyPathdi = bodyPath + "." + strconv.Itoa(mi) + ".rtmapRule.children"
						break
					}
				}
				if matchBodyPathdi == "" {
					break
				}
				for _, stateChild := range state.RouteMaps[di].Entries {
					found := false
					for _, planChild := range data.RouteMaps[pdi].Entries {
						if stateChild.Order == planChild.Order {
							found = true
							break
						}
					}
					if !found {
						deleteBody := ""
						deleteBody, _ = sjson.Set(deleteBody, "rtmapEntry.attributes.rn", stateChild.getRn())
						deleteBody, _ = sjson.Set(deleteBody, "rtmapEntry.attributes.status", "deleted")
						body.Str, _ = sjson.SetRaw(body.Str, matchBodyPathdi+".-1", deleteBody)
					}
				}
				for di_ := range state.RouteMaps[di].Entries {
					for pdi_ := range data.RouteMaps[pdi].Entries {
						if state.RouteMaps[di].Entries[di_].Order == data.RouteMaps[pdi].Entries[pdi_].Order {
							matchBodyPathdi_ := ""
							for mi, mv := range gjson.Get(body.Str, matchBodyPathdi).Array() {
								if mv.Get("rtmapEntry.attributes.rn").String() == state.RouteMaps[di].Entries[di_].getRn() {
									matchBodyPathdi_ = matchBodyPathdi + "." + strconv.Itoa(mi) + ".rtmapEntry.children"
									break
								}
							}
							if matchBodyPathdi_ == "" {
								break
							}
							for _, stateChild := range state.RouteMaps[di].Entries[di_].MatchRoutePrefixLists {
								found := false
								for _, planChild := range data.RouteMaps[pdi].Entries[pdi_].MatchRoutePrefixLists {
									if stateChild.PrefixListDn == planChild.PrefixListDn {
										found = true
										break
									}
								}
								if !found {
									deleteBody := ""
									deleteBody, _ = sjson.Set(deleteBody, "rtmapRsRtDstAtt.attributes.rn", stateChild.getRn())
									deleteBody, _ = sjson.Set(deleteBody, "rtmapRsRtDstAtt.attributes.status", "deleted")
									body.Str, _ = sjson.SetRaw(body.Str, matchBodyPathdi_+".0.rtmapMatchRtDst.children"+".-1", deleteBody)
								}
							}
							for _, stateChild := range state.RouteMaps[di].Entries[di_].SetRegularCommunityItems {
								found := false
								for _, planChild := range data.RouteMaps[pdi].Entries[pdi_].SetRegularCommunityItems {
									if stateChild.Community == planChild.Community {
										found = true
										break
									}
								}
								if !found {
									deleteBody := ""
									deleteBody, _ = sjson.Set(deleteBody, "rtregcomItem.attributes.rn", stateChild.getRn())
									deleteBody, _ = sjson.Set(deleteBody, "rtregcomItem.attributes.status", "deleted")
									body.Str, _ = sjson.SetRaw(body.Str, matchBodyPathdi_+".0.rtmapSetRegComm.children"+".-1", deleteBody)
								}
							}
							for _, stateChild := range state.RouteMaps[di].Entries[di_].MatchTags {
								found := false
								for _, planChild := range data.RouteMaps[pdi].Entries[pdi_].MatchTags {
									if stateChild.Tag == planChild.Tag {
										found = true
										break
									}
								}
								if !found {
									deleteBody := ""
									deleteBody, _ = sjson.Set(deleteBody, "rtmapMatchRtTag.attributes.rn", stateChild.getRn())
									deleteBody, _ = sjson.Set(deleteBody, "rtmapMatchRtTag.attributes.status", "deleted")
									body.Str, _ = sjson.SetRaw(body.Str, matchBodyPathdi_+".-1", deleteBody)
								}
							}
							break
						}
					}
				}
				break
			}
		}
	}
	return body
}

// End of section. //template:end toDeleteBody
