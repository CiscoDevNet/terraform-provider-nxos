// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports

import (
	"context"
	"fmt"
	"strconv"

	"github.com/CiscoDevNet/terraform-provider-nxos/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-nxos"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

type VRFs struct {
	Device types.String `tfsdk:"device"`
	Dn     types.String `tfsdk:"id"`
	Items  []VRFsItems  `tfsdk:"items"`
}

type VRFsItems struct {
	Name               types.String          `tfsdk:"name"`
	Description        types.String          `tfsdk:"description"`
	AdminState         types.String          `tfsdk:"admin_state"`
	ControllerId       types.Int64           `tfsdk:"controller_id"`
	Encap              types.String          `tfsdk:"encap"`
	L3vni              types.Bool            `tfsdk:"l3vni"`
	Oui                types.String          `tfsdk:"oui"`
	VpnId              types.String          `tfsdk:"vpn_id"`
	RoutingEncap       types.String          `tfsdk:"routing_encap"`
	RouteDistinguisher types.String          `tfsdk:"route_distinguisher"`
	AddressFamilies    []VRFsAddressFamilies `tfsdk:"address_families"`
}

type VRFsAddressFamilies struct {
	AddressFamily              types.String                     `tfsdk:"address_family"`
	RouteTargetAddressFamilies []VRFsRouteTargetAddressFamilies `tfsdk:"route_target_address_families"`
}

type VRFsRouteTargetAddressFamilies struct {
	RouteTargetAddressFamily types.String                `tfsdk:"route_target_address_family"`
	RouteTargetDirections    []VRFsRouteTargetDirections `tfsdk:"route_target_directions"`
}

type VRFsRouteTargetDirections struct {
	Direction    types.String       `tfsdk:"direction"`
	RouteTargets []VRFsRouteTargets `tfsdk:"route_targets"`
}

type VRFsRouteTargets struct {
	RouteTarget types.String `tfsdk:"route_target"`
}

type VRFsIdentity struct {
	Device types.String `tfsdk:"device"`
}

func (data *VRFsIdentity) toIdentity(ctx context.Context, plan *VRFs) {
	if plan.Device.IsNull() {
		data.Device = types.StringValue("")
	} else {
		data.Device = plan.Device
	}
}

func (data *VRFs) fromIdentity(ctx context.Context, identity *VRFsIdentity) {
	if identity.Device.ValueString() == "" {
		data.Device = types.StringNull()
	} else {
		data.Device = identity.Device
	}
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data VRFs) getDn() string {
	return "sys"
}

func (data VRFs) getClassName() string {
	return "topSystem"
}

func (data VRFs) getItemClassName() string {
	return "l3Inst"
}

func (data VRFs) getItemDn(item VRFsItems) string {
	return fmt.Sprintf("sys/inst-[%s]", item.Name.ValueString())
}

func (data VRFs) getItemRn(item VRFsItems) string {
	return fmt.Sprintf("inst-[%s]", item.Name.ValueString())
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data VRFs) toBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	childrenPath := data.getClassName() + ".children"

	for _, item := range data.Items {
		itemBody := ""
		itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes", map[string]interface{}{})
		if (!item.Name.IsUnknown() && !item.Name.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"name", item.Name.ValueString())
		}
		if (!item.Description.IsUnknown() && !item.Description.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"descr", item.Description.ValueString())
		}
		if (!item.AdminState.IsUnknown() && !item.AdminState.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"adminState", item.AdminState.ValueString())
		}
		if (!item.ControllerId.IsUnknown() && !item.ControllerId.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"ctrlrId", strconv.FormatInt(item.ControllerId.ValueInt64(), 10))
		}
		if (!item.Encap.IsUnknown() && !item.Encap.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"encap", item.Encap.ValueString())
		}
		if (!item.L3vni.IsUnknown() && !item.L3vni.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"l3vni", strconv.FormatBool(item.L3vni.ValueBool()))
		}
		if (!item.Oui.IsUnknown() && !item.Oui.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"oui", item.Oui.ValueString())
		}
		if (!item.VpnId.IsUnknown() && !item.VpnId.IsNull()) || false {
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"vpnId", item.VpnId.ValueString())
		}
		var attrs string
		itemChildrenPath := data.getItemClassName() + ".children"
		{
			childIndex := len(gjson.Get(itemBody, itemChildrenPath).Array())
			childBodyPath := itemChildrenPath + "." + strconv.Itoa(childIndex) + ".rtctrlDom"
			attrs = "{}"
			attrs, _ = sjson.Set(attrs, "name", item.Name.ValueString())
			if (!item.RoutingEncap.IsUnknown() && !item.RoutingEncap.IsNull()) || false {
				attrs, _ = sjson.Set(attrs, "encap", item.RoutingEncap.ValueString())
			}
			if (!item.RouteDistinguisher.IsUnknown() && !item.RouteDistinguisher.IsNull()) || false {
				attrs, _ = sjson.Set(attrs, "rd", item.RouteDistinguisher.ValueString())
			}
			itemBody, _ = sjson.SetRaw(itemBody, childBodyPath+".attributes", attrs)
			nestedChildrenPath := childBodyPath + ".children"
			for _, child := range item.AddressFamilies {
				attrs = "{}"
				if (!child.AddressFamily.IsUnknown() && !child.AddressFamily.IsNull()) || false {
					attrs, _ = sjson.Set(attrs, "type", child.AddressFamily.ValueString())
				}
				itemBody, _ = sjson.SetRaw(itemBody, nestedChildrenPath+".-1.rtctrlDomAf.attributes", attrs)
				{
					nestedIndex := len(gjson.Get(itemBody, nestedChildrenPath).Array()) - 1
					nestedChildrenPath := nestedChildrenPath + "." + strconv.Itoa(nestedIndex) + ".rtctrlDomAf.children"
					for _, child := range child.RouteTargetAddressFamilies {
						attrs = "{}"
						if (!child.RouteTargetAddressFamily.IsUnknown() && !child.RouteTargetAddressFamily.IsNull()) || false {
							attrs, _ = sjson.Set(attrs, "type", child.RouteTargetAddressFamily.ValueString())
						}
						itemBody, _ = sjson.SetRaw(itemBody, nestedChildrenPath+".-1.rtctrlAfCtrl.attributes", attrs)
						{
							nestedIndex := len(gjson.Get(itemBody, nestedChildrenPath).Array()) - 1
							nestedChildrenPath := nestedChildrenPath + "." + strconv.Itoa(nestedIndex) + ".rtctrlAfCtrl.children"
							for _, child := range child.RouteTargetDirections {
								attrs = "{}"
								if (!child.Direction.IsUnknown() && !child.Direction.IsNull()) || false {
									attrs, _ = sjson.Set(attrs, "type", child.Direction.ValueString())
								}
								itemBody, _ = sjson.SetRaw(itemBody, nestedChildrenPath+".-1.rtctrlRttP.attributes", attrs)
								{
									nestedIndex := len(gjson.Get(itemBody, nestedChildrenPath).Array()) - 1
									nestedChildrenPath := nestedChildrenPath + "." + strconv.Itoa(nestedIndex) + ".rtctrlRttP.children"
									for _, child := range child.RouteTargets {
										attrs = "{}"
										if (!child.RouteTarget.IsUnknown() && !child.RouteTarget.IsNull()) || false {
											attrs, _ = sjson.Set(attrs, "rtt", child.RouteTarget.ValueString())
										}
										itemBody, _ = sjson.SetRaw(itemBody, nestedChildrenPath+".-1.rtctrlRttEntry.attributes", attrs)
									}
								}
							}
						}
					}
				}
			}
		}
		_ = attrs

		body, _ = sjson.SetRaw(body, childrenPath+".-1", itemBody)
	}

	return nxos.Body{body}
}

func (data VRFs) toDeleteBody(items []VRFsItems) nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	childrenPath := data.getClassName() + ".children"
	for _, item := range items {
		itemBody := ""
		itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes.rn", data.getItemRn(item))
		itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes.status", "deleted")
		body, _ = sjson.SetRaw(body, childrenPath+".-1", itemBody)
	}
	return nxos.Body{body}
}

func (data VRFs) toBodyWithDeletes(ctx context.Context, state VRFs) nxos.Body {
	body := data.toBody()
	childrenPath := data.getClassName() + ".children"
	for _, stateItem := range state.Items {
		found := false
		for _, planItem := range data.Items {
			if planItem.Name.ValueString() != stateItem.Name.ValueString() {
				continue
			}
			found = true
			break
		}
		if !found {
			itemBody := ""
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes.rn", data.getItemRn(stateItem))
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes.status", "deleted")
			body.Str, _ = sjson.SetRaw(body.Str, childrenPath+".-1", itemBody)
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *VRFs) fromBody(res gjson.Result) {
	data.Items = make([]VRFsItems, 0)
	res.Get(data.getClassName() + ".children").ForEach(func(_, v gjson.Result) bool {
		v.ForEach(func(classname, value gjson.Result) bool {
			if classname.String() == data.getItemClassName() {
				item := VRFsItems{}
				item.Name = types.StringValue(value.Get("attributes.name").String())
				item.Description = types.StringValue(value.Get("attributes.descr").String())
				item.AdminState = types.StringValue(value.Get("attributes.adminState").String())
				item.ControllerId = types.Int64Value(value.Get("attributes.ctrlrId").Int())
				item.Encap = types.StringValue(value.Get("attributes.encap").String())
				item.L3vni = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.l3vni").String()))
				item.Oui = types.StringValue(value.Get("attributes.oui").String())
				item.VpnId = types.StringValue(value.Get("attributes.vpnId").String())
				{
					var rrtctrlDom gjson.Result
					value.Get("children").ForEach(
						func(_, nestedV gjson.Result) bool {
							key := nestedV.Get("rtctrlDom.attributes.rn").String()
							if key == fmt.Sprintf("dom-%[1]s", item.Name.ValueString()) {
								rrtctrlDom = nestedV
								return false
							}
							return true
						},
					)
					item.RoutingEncap = types.StringValue(rrtctrlDom.Get("rtctrlDom.attributes.encap").String())
					item.RouteDistinguisher = types.StringValue(rrtctrlDom.Get("rtctrlDom.attributes.rd").String())
					rrtctrlDom.Get("rtctrlDom").Get("children").ForEach(
						func(_, nestedV gjson.Result) bool {
							nestedV.ForEach(
								func(nestedClassname, nestedValue gjson.Result) bool {
									if nestedClassname.String() == "rtctrlDomAf" {
										var nestedChildrtctrlDomAf VRFsAddressFamilies
										nestedChildrtctrlDomAf.AddressFamily = types.StringValue(nestedValue.Get("attributes.type").String())
										nestedValue.Get("children").ForEach(
											func(_, nestedV gjson.Result) bool {
												nestedV.ForEach(
													func(nestedClassname, nestedValue gjson.Result) bool {
														if nestedClassname.String() == "rtctrlAfCtrl" {
															var nestedChildrtctrlAfCtrl VRFsRouteTargetAddressFamilies
															nestedChildrtctrlAfCtrl.RouteTargetAddressFamily = types.StringValue(nestedValue.Get("attributes.type").String())
															nestedValue.Get("children").ForEach(
																func(_, nestedV gjson.Result) bool {
																	nestedV.ForEach(
																		func(nestedClassname, nestedValue gjson.Result) bool {
																			if nestedClassname.String() == "rtctrlRttP" {
																				var nestedChildrtctrlRttP VRFsRouteTargetDirections
																				nestedChildrtctrlRttP.Direction = types.StringValue(nestedValue.Get("attributes.type").String())
																				nestedValue.Get("children").ForEach(
																					func(_, nestedV gjson.Result) bool {
																						nestedV.ForEach(
																							func(nestedClassname, nestedValue gjson.Result) bool {
																								if nestedClassname.String() == "rtctrlRttEntry" {
																									var nestedChildrtctrlRttEntry VRFsRouteTargets
																									nestedChildrtctrlRttEntry.RouteTarget = types.StringValue(nestedValue.Get("attributes.rtt").String())
																									nestedChildrtctrlRttP.RouteTargets = append(nestedChildrtctrlRttP.RouteTargets, nestedChildrtctrlRttEntry)
																								}
																								return true
																							},
																						)
																						return true
																					},
																				)
																				nestedChildrtctrlAfCtrl.RouteTargetDirections = append(nestedChildrtctrlAfCtrl.RouteTargetDirections, nestedChildrtctrlRttP)
																			}
																			return true
																		},
																	)
																	return true
																},
															)
															nestedChildrtctrlDomAf.RouteTargetAddressFamilies = append(nestedChildrtctrlDomAf.RouteTargetAddressFamilies, nestedChildrtctrlAfCtrl)
														}
														return true
													},
												)
												return true
											},
										)
										item.AddressFamilies = append(item.AddressFamilies, nestedChildrtctrlDomAf)
									}
									return true
								},
							)
							return true
						},
					)
				}
				data.Items = append(data.Items, item)
			}
			return true
		})
		return true
	})
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *VRFs) updateFromBody(res gjson.Result) {
	for i := range data.Items {
		// Find the matching item in the response by id attributes
		res.Get(data.getClassName() + ".children").ForEach(func(_, v gjson.Result) bool {
			v.ForEach(func(classname, value gjson.Result) bool {
				if classname.String() == data.getItemClassName() {
					if value.Get("attributes.name").String() != data.Items[i].Name.ValueString() {
						return true
					}
					// Found matching item, update attributes
					if !data.Items[i].Name.IsNull() {
						data.Items[i].Name = types.StringValue(value.Get("attributes.name").String())
					} else {
						data.Items[i].Name = types.StringNull()
					}
					if !data.Items[i].Description.IsNull() {
						data.Items[i].Description = types.StringValue(value.Get("attributes.descr").String())
					} else {
						data.Items[i].Description = types.StringNull()
					}
					if !data.Items[i].AdminState.IsNull() {
						data.Items[i].AdminState = types.StringValue(value.Get("attributes.adminState").String())
					} else {
						data.Items[i].AdminState = types.StringNull()
					}
					if !data.Items[i].ControllerId.IsNull() {
						data.Items[i].ControllerId = types.Int64Value(value.Get("attributes.ctrlrId").Int())
					} else {
						data.Items[i].ControllerId = types.Int64Null()
					}
					if !data.Items[i].Encap.IsNull() {
						data.Items[i].Encap = types.StringValue(value.Get("attributes.encap").String())
					} else {
						data.Items[i].Encap = types.StringNull()
					}
					if !data.Items[i].L3vni.IsNull() {
						data.Items[i].L3vni = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.l3vni").String()))
					} else {
						data.Items[i].L3vni = types.BoolNull()
					}
					if !data.Items[i].Oui.IsNull() {
						data.Items[i].Oui = types.StringValue(value.Get("attributes.oui").String())
					} else {
						data.Items[i].Oui = types.StringNull()
					}
					if !data.Items[i].VpnId.IsNull() {
						data.Items[i].VpnId = types.StringValue(value.Get("attributes.vpnId").String())
					} else {
						data.Items[i].VpnId = types.StringNull()
					}
					{
						var rrtctrlDom gjson.Result
						value.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								key := nestedV.Get("rtctrlDom.attributes.rn").String()
								if key == fmt.Sprintf("dom-%[1]s", data.Items[i].Name.ValueString()) {
									rrtctrlDom = nestedV
									return false
								}
								return true
							},
						)
						if !data.Items[i].RoutingEncap.IsNull() {
							data.Items[i].RoutingEncap = types.StringValue(rrtctrlDom.Get("rtctrlDom.attributes.encap").String())
						} else {
							data.Items[i].RoutingEncap = types.StringNull()
						}
						if !data.Items[i].RouteDistinguisher.IsNull() {
							data.Items[i].RouteDistinguisher = types.StringValue(rrtctrlDom.Get("rtctrlDom.attributes.rd").String())
						} else {
							data.Items[i].RouteDistinguisher = types.StringNull()
						}
						for c := range data.Items[i].AddressFamilies {
							var rrtctrlDomAf gjson.Result
							rrtctrlDom.Get("rtctrlDom").Get("children").ForEach(
								func(_, nestedV gjson.Result) bool {
									key := nestedV.Get("rtctrlDomAf.attributes.rn").String()
									if key == fmt.Sprintf("af-[%s]", data.Items[i].AddressFamilies[c].AddressFamily.ValueString()) {
										rrtctrlDomAf = nestedV
										return false
									}
									return true
								},
							)
							if !data.Items[i].AddressFamilies[c].AddressFamily.IsNull() {
								data.Items[i].AddressFamilies[c].AddressFamily = types.StringValue(rrtctrlDomAf.Get("rtctrlDomAf.attributes.type").String())
							} else {
								data.Items[i].AddressFamilies[c].AddressFamily = types.StringNull()
							}
							for cc := range data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies {
								var rrtctrlAfCtrl gjson.Result
								rrtctrlDomAf.Get("rtctrlDomAf").Get("children").ForEach(
									func(_, nestedV gjson.Result) bool {
										key := nestedV.Get("rtctrlAfCtrl.attributes.rn").String()
										if key == fmt.Sprintf("ctrl-[%s]", data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetAddressFamily.ValueString()) {
											rrtctrlAfCtrl = nestedV
											return false
										}
										return true
									},
								)
								if !data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetAddressFamily.IsNull() {
									data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetAddressFamily = types.StringValue(rrtctrlAfCtrl.Get("rtctrlAfCtrl.attributes.type").String())
								} else {
									data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetAddressFamily = types.StringNull()
								}
								for ccc := range data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections {
									var rrtctrlRttP gjson.Result
									rrtctrlAfCtrl.Get("rtctrlAfCtrl").Get("children").ForEach(
										func(_, nestedV gjson.Result) bool {
											key := nestedV.Get("rtctrlRttP.attributes.rn").String()
											if key == fmt.Sprintf("rttp-%s", data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].Direction.ValueString()) {
												rrtctrlRttP = nestedV
												return false
											}
											return true
										},
									)
									if !data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].Direction.IsNull() {
										data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].Direction = types.StringValue(rrtctrlRttP.Get("rtctrlRttP.attributes.type").String())
									} else {
										data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].Direction = types.StringNull()
									}
									for cccc := range data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].RouteTargets {
										var rrtctrlRttEntry gjson.Result
										rrtctrlRttP.Get("rtctrlRttP").Get("children").ForEach(
											func(_, nestedV gjson.Result) bool {
												key := nestedV.Get("rtctrlRttEntry.attributes.rn").String()
												if key == fmt.Sprintf("ent-[%s]", data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].RouteTargets[cccc].RouteTarget.ValueString()) {
													rrtctrlRttEntry = nestedV
													return false
												}
												return true
											},
										)
										if !data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].RouteTargets[cccc].RouteTarget.IsNull() {
											data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].RouteTargets[cccc].RouteTarget = types.StringValue(rrtctrlRttEntry.Get("rtctrlRttEntry.attributes.rtt").String())
										} else {
											data.Items[i].AddressFamilies[c].RouteTargetAddressFamilies[cc].RouteTargetDirections[ccc].RouteTargets[cccc].RouteTarget = types.StringNull()
										}
									}
								}
							}
						}
					}
				}
				return true
			})
			return true
		})
	}
}

// End of section. //template:end updateFromBody
