//go:build ignore
// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-nxos"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"github.com/CiscoDevNet/terraform-provider-nxos/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

{{- /* ==================== structFieldsTemplate ====================
       Recursively emits struct fields for TfChildClasses.
       - single: flatten attributes into parent struct, recurse
       - list: emit slice field, recurse
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "structFieldsTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "single"}}
{{- range .Attributes}}
    {{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- else if eq .Type "list"}}
	{{toGoName .TfName}} []{{$typePrefix}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end structFieldsTemplate ==================== */}}

{{- /* ==================== childStructTypesTemplate ====================
       Recursively declares struct types for list-type TfChildClasses.
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "childStructTypesTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}

type {{$typePrefix}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
}
{{- end}}
{{- if .TfChildClasses}}
{{- template "childStructTypesTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end childStructTypesTemplate ==================== */}}

{{ $name := camelCase .Name}}
type {{camelCase .Name}} struct {
	Device types.String `tfsdk:"device"`
	Dn types.String `tfsdk:"id"`
{{- range .Attributes}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $name "Children" .TfChildClasses)}}
}
{{- template "childStructTypesTemplate" (makeMap "TypePrefix" $name "Children" .TfChildClasses)}}


type {{camelCase .Name}}Identity struct {
	Device types.String `tfsdk:"device"`
{{- range (importAttributes .)}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
}

func (data *{{camelCase .Name}}Identity) toIdentity(ctx context.Context, plan *{{camelCase .Name}}) {
	if plan.Device.IsNull() {
		data.Device = types.StringValue("")
	} else {
		data.Device = plan.Device
	}
{{- range (importAttributes .)}}
	data.{{toGoName .TfName}} = plan.{{toGoName .TfName}}
{{- end}}
}

func (data *{{camelCase .Name}}) fromIdentity(ctx context.Context, identity *{{camelCase .Name}}Identity) {
	if identity.Device.ValueString() == "" {
		data.Device = types.StringNull()
	} else {
		data.Device = identity.Device
	}
{{- range (importAttributes .)}}
	data.{{toGoName .TfName}} = identity.{{toGoName .TfName}}
{{- end}}
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data {{camelCase .Name}}) getDn() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Dn}}"{{range .Attributes}}{{if .Id}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{.Dn}}"
{{- end}}
}

{{- /* ==================== getRnTemplate ====================
       Recursively generates getRn() methods for all list-type child classes.
       Context: map with "TypePrefix" (string) and "Children" ([]YamlConfigChildClass)
       ========================================================= */}}
{{- define "getRnTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}

func (data {{$typePrefix}}{{toGoName .TfName}}) getRn() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Rn}}"{{range .Attributes}}{{if .Id}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{.Rn}}"
{{- end}}
}
{{- end}}
{{- if .ChildClasses}}
{{- template "getRnTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses)}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end getRnTemplate ==================== */}}

{{- template "getRnTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses)}}

func (data {{camelCase .Name}}) getClassName() string {
	return "{{.ClassName}}"
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

{{- /* ==================== toBodyChildrenTemplate ====================
       Recursively generates sjson body-building code for child classes.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "DataVar" (string) - Go variable holding data (e.g. "data", "child")
         "ChildrenPathVar" (string) - Go variable name holding the sjson path to the children array
       ========================================================= */}}
{{- define "toBodyChildrenTemplate"}}
{{- $dataVar := .DataVar}}
{{- $childrenPathVar := .ChildrenPathVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childAlwaysInclude := .AlwaysInclude}}
{{- if eq .Type "single"}}
{{- if .ChildClasses}}
	{
	childIndex := len(gjson.Get(body, {{$childrenPathVar}}).Array())
	childBodyPath := {{$childrenPathVar}} + "." + strconv.Itoa(childIndex) + ".{{$childClassName}}"
	attrs = "{}"
	{{- range .Attributes}}
	{{- if .Value}}
	attrs, _ = sjson.Set(attrs, "{{.NxosName}}", "{{.Value}}")
	{{- else if not .ReferenceOnly}}
	if (!{{$dataVar}}.{{toGoName .TfName}}.IsUnknown() && !{{$dataVar}}.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt({{$dataVar}}.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool({{$dataVar}}.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", {{$dataVar}}.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	body, _ = sjson.SetRaw(body, childBodyPath+".attributes", attrs)
	nestedChildrenPath := childBodyPath + ".children"
	{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" $dataVar "ChildrenPathVar" "nestedChildrenPath")}}
	}
{{- else}}
	attrs = "{}"
	{{- range .Attributes}}
	{{- if .Value}}
	attrs, _ = sjson.Set(attrs, "{{.NxosName}}", "{{.Value}}")
	{{- else if not .ReferenceOnly}}
	if (!{{$dataVar}}.{{toGoName .TfName}}.IsUnknown() && !{{$dataVar}}.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt({{$dataVar}}.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool({{$dataVar}}.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", {{$dataVar}}.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	if attrs != "{}" || {{$childAlwaysInclude}} {
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
	}
{{- end}}
{{- else if eq .Type "list"}}
	for _, child := range {{$dataVar}}.{{toGoName .TfName}} {
		attrs = "{}"
		{{- range .Attributes}}
		if (!child.{{toGoName .TfName}}.IsUnknown() && !child.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
			{{- if eq .Type "Int64"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt(child.{{toGoName .TfName}}.ValueInt64(), 10))
			{{- else if eq .Type "Bool"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool(child.{{toGoName .TfName}}.ValueBool()))
			{{- else if eq .Type "String"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", child.{{toGoName .TfName}}.ValueString())
			{{- end}}
		}
		{{- end}}
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
		{{- if .ChildClasses}}
		{
		nestedIndex := len(gjson.Get(body, {{$childrenPathVar}}).Array()) - 1
		nestedChildrenPath := {{$childrenPathVar}} + "." + strconv.Itoa(nestedIndex) + ".{{$childClassName}}.children"
		{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" "child" "ChildrenPathVar" "nestedChildrenPath")}}
		}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toBodyChildrenTemplate ==================== */}}

func (data {{camelCase .Name}}) toBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	{{- range .Attributes}}
	{{- if not .ReferenceOnly}}
	if (!data.{{toGoName .TfName}}.IsUnknown() && !data.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatInt(data.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatBool(data.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", data.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}

	{{- if .ChildClasses}}
	var attrs string
	childrenPath := data.getClassName() + ".children"
	{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" "data" "ChildrenPathVar" "childrenPath")}}
	{{- end}}

	return nxos.Body{body}
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

{{- /* ==================== fromBodyChildrenTemplate ====================
       Recursively generates gjson parsing code for child classes in fromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for the parent gjson result
         "DataVar" (string) - Go expression for data accessor (e.g. "data", "child")
       ========================================================= */}}
{{- define "fromBodyChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataVar := .DataVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- if or (len .Attributes) .ChildClasses}}
{{- if eq .Type "single"}}
{{- $hasNonRefAttribs := false}}
{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
{{- if or $hasNonRefAttribs .ChildClasses}}
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{$childRn}}" {
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
{{- end}}
{{- range .Attributes}}
{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
{{- if eq .Type "Int64"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
{{- else if eq .Type "Bool"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
{{- else if eq .Type "String"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
{{- end}}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
	{{- template "fromBodyChildrenTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataVar" $dataVar)}}
{{- end}}
{{- else if eq .Type "list"}}
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			v.ForEach(
				func(classname, value gjson.Result) bool {
					if classname.String() == "{{$childClassName}}" {
						var child {{$typePrefix}}{{toGoName .TfName}}
						{{- range .Attributes}}
						{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
						{{- if eq .Type "Int64"}}
						child.{{toGoName .TfName}} = types.Int64Value(value.Get("attributes.{{.NxosName}}").Int())
						{{- else if eq .Type "Bool"}}
						child.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.{{.NxosName}}").String()))
						{{- else if eq .Type "String"}}
						child.{{toGoName .TfName}} = types.StringValue(value.Get("attributes.{{.NxosName}}").String())
						{{- end}}
						{{- end}}
						{{- end}}
						{{- if .ChildClasses}}
						{{- template "fromBodyListChildrenTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ValueVar" "value" "ParentVar" "child")}}
						{{- end}}
						{{$dataVar}}.{{toGoName .TfName}} = append({{$dataVar}}.{{toGoName .TfName}}, child)
					}
					return true
				},
			)
			return true
		},
	)
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end fromBodyChildrenTemplate ==================== */}}

{{- /* ==================== fromBodyListChildrenTemplate ====================
       Recursively generates gjson parsing code for children of list-type parents
       in fromBody. Inside a ForEach callback, the value variable is unwrapped.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ValueVar" (string) - Go variable for parent's gjson value
         "ParentVar" (string) - Go variable for the parent struct being built
       ========================================================= */}}
{{- define "fromBodyListChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $valueVar := .ValueVar}}
{{- $parentVar := .ParentVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
						{{$valueVar}}.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								nestedV.ForEach(
									func(nestedClassname, nestedValue gjson.Result) bool {
										if nestedClassname.String() == "{{$childClassName}}" {
											var nestedChild {{$typePrefix}}{{toGoName .TfName}}
											{{- range .Attributes}}
											{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
											{{- if eq .Type "Int64"}}
											nestedChild.{{toGoName .TfName}} = types.Int64Value(nestedValue.Get("attributes.{{.NxosName}}").Int())
											{{- else if eq .Type "Bool"}}
											nestedChild.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(nestedValue.Get("attributes.{{.NxosName}}").String()))
											{{- else if eq .Type "String"}}
											nestedChild.{{toGoName .TfName}} = types.StringValue(nestedValue.Get("attributes.{{.NxosName}}").String())
											{{- end}}
											{{- end}}
											{{- end}}
											{{- if .ChildClasses}}
											{{- template "fromBodyListChildrenTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ValueVar" "nestedValue" "ParentVar" "nestedChild")}}
											{{- end}}
											{{$parentVar}}.{{toGoName .TfName}} = append({{$parentVar}}.{{toGoName .TfName}}, nestedChild)
										}
										return true
									},
								)
								return true
							},
						)
{{- end}}
{{- end}}
{{- /* ==================== end fromBodyListChildrenTemplate ==================== */}}

func (data *{{camelCase .Name}}) fromBody(res gjson.Result) {
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	data.{{toGoName .TfName}} = types.Int64Value(res.Get(data.getClassName()+".attributes.{{.NxosName}}").Int())
	{{- else if eq .Type "Bool"}}
	data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String()))
	{{- else if eq .Type "String"}}
	data.{{toGoName .TfName}} = types.StringValue(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String())
	{{- end}}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "fromBodyChildrenTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses "ResExpr" (printf "res.Get(data.getClassName() + \".children\")") "DataVar" "data")}}
	{{- end}}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

{{- /* ==================== updateFromBodySingleChildTemplate ====================
       Recursively generates update code for single-type children in updateFromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for parent result's children
         "DataAccessor" (string) - Go expression prefix for data access
       ========================================================= */}}
{{- define "updateFromBodySingleChildTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataAccessor := .DataAccessor}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- $list := (toGoName .TfName)}}
{{- if eq .Type "single"}}
{{- $hasNonRefAttribs := false}}
{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
{{- $hasChildren := false}}
{{- if .ChildClasses}}{{$hasChildren = true}}{{end}}
{{- if or $hasNonRefAttribs $hasChildren}}
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{$childRn}}" {
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
{{- end}}
{{- range .Attributes}}
{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !{{$dataAccessor}}.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		{{$dataAccessor}}.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
	{{- template "updateFromBodySingleChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataAccessor" $dataAccessor)}}
{{- end}}
{{- else if eq .Type "list"}}
	for c := range {{$dataAccessor}}.{{$list}} {
		var r{{$childClassName}} gjson.Result
		{{$resExpr}}.ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == {{$dataAccessor}}.{{$list}}[c].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "%s.%s[c]" $dataAccessor $list) "IndexVar" "nc")}}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end updateFromBodySingleChildTemplate ==================== */}}

{{- /* ==================== updateFromBodyListChildTemplate ====================
       Recursively generates update code for list-type children in updateFromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for parent result's children
         "DataListExpr" (string) - Go expression for data list (e.g. "data.Interfaces")
         "IndexVar" (string) - Loop index variable name
       ========================================================= */}}
{{- define "updateFromBodyListChildTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataListExpr := .DataListExpr}}
{{- $indexVar := .IndexVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- $list := (toGoName .TfName)}}
{{- if eq .Type "single"}}
	{
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{$childRn}}" {
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !{{$dataListExpr}}.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		{{$dataListExpr}}.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" $dataListExpr "IndexVar" $indexVar)}}
	{{- end}}
	}
{{- else if eq .Type "list"}}
	for {{$indexVar}} := range {{$dataListExpr}}.{{$list}} {
		var r{{$childClassName}} gjson.Result
		{{$resExpr}}.ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == {{$dataListExpr}}.{{$list}}[{{$indexVar}}].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "%s.%s[%s]" $dataListExpr $list $indexVar) "IndexVar" (printf "%s_" $indexVar))}}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end updateFromBodyListChildTemplate ==================== */}}

func (data *{{camelCase .Name}}) updateFromBody(res gjson.Result) {
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		data.{{toGoName .TfName}} = types.Int64Value(res.Get(data.getClassName()+".attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		data.{{toGoName .TfName}} = types.StringValue(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- range .ChildClasses}}
	{{- $childClassName := .ClassName}}
	{{- $childRn := .Rn}}
	{{- $list := (toGoName .TfName)}}
	{{- if eq .Type "single"}}
	{{- $hasNonRefAttribs := false}}
	{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
	{{- $hasChildren := false}}
	{{- if .ChildClasses}}{{$hasChildren = true}}{{end}}
	{{- if or $hasNonRefAttribs $hasChildren}}
	var r{{$childClassName}} gjson.Result
	res.Get(data.getClassName() + ".children").ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{$childRn}}" {
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
	{{- end}}
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		data.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		data.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "updateFromBodySingleChildTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataAccessor" "data")}}
	{{- end}}
	{{- else if eq .Type "list"}}
	for c := range data.{{toGoName .TfName}} {
		var r{{$childClassName}} gjson.Result
		res.Get(data.getClassName() + ".children").ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == data.{{$list}}[c].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !data.{{$list}}[c].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			data.{{$list}}[c].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "data.%s[c]" $list) "IndexVar" "nc")}}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin toDeleteBody

{{- /* ==================== toDeleteBodyChildrenTemplate ====================
       Recursively generates sjson body-building code for NoDelete children with DeleteValue attrs.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "BodyPathSuffix" (string) - static sjson path suffix after getClassName()
       ========================================================= */}}
{{- define "toDeleteBodyChildrenTemplate"}}
{{- $bodyPathSuffix := .BodyPathSuffix}}
{{- range .Children}}
{{- if .NoDelete}}
{{- $childClassName := .ClassName}}
{{- $childSuffix := (printf "%s.children.-1.%s" $bodyPathSuffix $childClassName)}}
{{- range .Attributes}}
{{- if and (not .ReferenceOnly) (.DeleteValue)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, data.getClassName()+"{{$childSuffix}}"+".attributes."+"{{.NxosName}}", strconv.FormatInt({{ .DeleteValue}}, 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, data.getClassName()+"{{$childSuffix}}"+".attributes."+"{{.NxosName}}", strconv.FormatBool({{ .DeleteValue}}))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, data.getClassName()+"{{$childSuffix}}"+".attributes."+"{{.NxosName}}", "{{ .DeleteValue}}")
		{{- end}}
	}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
{{- template "toDeleteBodyChildrenTemplate" (makeMap "Children" .ChildClasses "BodyPathSuffix" $childSuffix)}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toDeleteBodyChildrenTemplate ==================== */}}

func (data {{camelCase .Name}}) toDeleteBody() nxos.Body {
	body := ""

	{{- range .Attributes}}
	{{- if and (not .ReferenceOnly) (.DeleteValue)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatInt({{ .DeleteValue}}, 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatBool({{ .DeleteValue}}))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", "{{ .DeleteValue}}")
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "toDeleteBodyChildrenTemplate" (makeMap "Children" .ChildClasses "BodyPathSuffix" "")}}
	{{- end}}

	return nxos.Body{body}
}

// End of section. //template:end toDeleteBody

// Section below is generated&owned by "gen/generator.go". //template:begin getDeleteDns

{{- /* ==================== getDeleteDnsTemplate ====================
       Recursively generates DN collection for deletable children.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "DnPrefix" (string) - Go expression prefix for building DN paths
       ========================================================= */}}
{{- define "getDeleteDnsTemplate"}}
{{- $dnPrefix := .DnPrefix}}
{{- range .Children}}
{{- if not .NoDelete}}
{{- if eq .Type "single"}}
	dns = append(dns, {{$dnPrefix}}+"/{{.Rn}}")
{{- else if eq .Type "list"}}
	for _, child := range data.{{toGoName .TfName}} {
		dns = append(dns, {{$dnPrefix}}+"/"+child.getRn())
	}
{{- end}}
{{- else}}
{{- if .ChildClasses}}
{{- if eq .Type "single"}}
{{- template "getDeleteDnsTemplate" (makeMap "Children" .ChildClasses "DnPrefix" (printf "%s+\"/%s\"" $dnPrefix .Rn))}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end getDeleteDnsTemplate ==================== */}}

func (data {{camelCase .Name}}) getDeleteDns() []string {
	dns := []string{}

	{{- if not .NoDelete}}
	dns = append(dns, data.getDn())
	{{- else}}
	{{- template "getDeleteDnsTemplate" (makeMap "Children" .ChildClasses "DnPrefix" "data.getDn()")}}
	{{- end}}

	return dns
}

// End of section. //template:end getDeleteDns

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

{{- /* ==================== getDeletedItemsListChildTemplate ====================
       Recursively detects deleted items within matched list-item pairs.
       Used when a list child itself has nested children that may be deleted.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "StateListExpr" (string) - Go expression for state list
         "PlanListExpr" (string) - Go expression for plan list
         "DnPrefix" (string) - Go expression prefix for DN paths
         "IdAttributes" ([]Attribute) - Attributes used to match items by ID
         "IndexVar" (string) - Loop index variable name
       ========================================================= */}}
{{- define "getDeletedItemsListChildTemplate"}}
{{- $stateListExpr := .StateListExpr}}
{{- $planListExpr := .PlanListExpr}}
{{- $dnPrefix := .DnPrefix}}
{{- $idAttributes := .IdAttributes}}
{{- $indexVar := .IndexVar}}
	for {{$indexVar}} := range {{$stateListExpr}} {
		for p{{$indexVar}} := range {{$planListExpr}} {
			if {{range $i, $a := $idAttributes}}{{if $a.Id}}{{if $i}} && {{end}}{{$stateListExpr}}[{{$indexVar}}].{{toGoName $a.TfName}} == {{$planListExpr}}[p{{$indexVar}}].{{toGoName $a.TfName}}{{end}}{{end}} {
				{{- range .Children}}
				{{- if eq .Type "list"}}
				for _, stateChild := range {{$stateListExpr}}[{{$indexVar}}].{{toGoName .TfName}} {
					found := false
					for _, planChild := range {{$planListExpr}}[p{{$indexVar}}].{{toGoName .TfName}} {
						if {{range $i, $a := .Attributes}}{{if $a.Id}}{{if $i}} && {{end}}stateChild.{{toGoName $a.TfName}} == planChild.{{toGoName $a.TfName}}{{end}}{{end}} {
							found = true
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, {{$dnPrefix}}+"/"+{{$stateListExpr}}[{{$indexVar}}].getRn()+"/"+stateChild.getRn())
					}
				}
				{{- if .ChildClasses}}
				{{- template "getDeletedItemsListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "%s[%s].%s" $stateListExpr $indexVar (toGoName .TfName)) "PlanListExpr" (printf "%s[p%s].%s" $planListExpr $indexVar (toGoName .TfName)) "DnPrefix" (printf "%s+\"/\"+%s[%s].getRn()" $dnPrefix $stateListExpr $indexVar) "IdAttributes" .Attributes "IndexVar" (printf "%s_" $indexVar))}}
				{{- end}}
				{{- else if eq .Type "single"}}
				{{- if .ChildClasses}}
				{{- template "getDeletedItemsListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "%s[%s]" $stateListExpr $indexVar) "PlanListExpr" (printf "%s[p%s]" $planListExpr $indexVar) "DnPrefix" (printf "%s+\"/\"+%s[%s].getRn()+\"/%s\"" $dnPrefix $stateListExpr $indexVar .Rn) "IdAttributes" .Attributes "IndexVar" $indexVar)}}
				{{- end}}
				{{- end}}
				{{- end}}
				break
			}
		}
	}
{{- end}}
{{- /* ==================== end getDeletedItemsListChildTemplate ==================== */}}

{{- /* ==================== getDeletedItemsTemplate ====================
       Recursively generates deleted-item detection for list children.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "DnPrefix" (string) - Go expression prefix for DN paths
       ========================================================= */}}
{{- define "getDeletedItemsTemplate"}}
{{- $dnPrefix := .DnPrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}
	for _, stateChild := range state.{{toGoName .TfName}} {
		found := false
		for _, planChild := range data.{{toGoName .TfName}} {
			if {{range $i, $a := .Attributes}}{{if $a.Id}}{{if $i}} && {{end}}stateChild.{{toGoName $a.TfName}} == planChild.{{toGoName $a.TfName}}{{end}}{{end}} {
				found = true
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, {{$dnPrefix}}+"/"+stateChild.getRn())
		}
	}
	{{- if .ChildClasses}}
	{{- template "getDeletedItemsListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "state.%s" (toGoName .TfName)) "PlanListExpr" (printf "data.%s" (toGoName .TfName)) "DnPrefix" $dnPrefix "IdAttributes" .Attributes "IndexVar" "di")}}
	{{- end}}
{{- else if eq .Type "single"}}
{{- if .ChildClasses}}
{{- template "getDeletedItemsTemplate" (makeMap "Children" .ChildClasses "DnPrefix" (printf "%s+\"/%s\"" $dnPrefix .Rn))}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end getDeletedItemsTemplate ==================== */}}

{{- if hasListChildClasses .ChildClasses}}

func (data {{camelCase .Name}}) getDeletedItems(ctx context.Context, state {{camelCase .Name}}) []string {
	deletedItems := []string{}
	{{- template "getDeletedItemsTemplate" (makeMap "Children" .ChildClasses "DnPrefix" "data.getDn()")}}
	return deletedItems
}
{{- end}}

// End of section. //template:end getDeletedItems
