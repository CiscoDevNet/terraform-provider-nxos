//go:build ignore
// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-nxos"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"github.com/CiscoDevNet/terraform-provider-nxos/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

{{ $bulkName := camelCase .BulkName}}
{{ $name := camelCase .Name}}
type {{camelCase .BulkName}} struct {
	Device types.String `tfsdk:"device"`
	Dn     types.String `tfsdk:"id"`
	Items  []{{camelCase .BulkName}}Items `tfsdk:"items"`
}

{{- /* ==================== bulkStructFieldsTemplate ====================
       Recursively emits struct fields for TfChildClasses.
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "bulkStructFieldsTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "single"}}
{{- range .Attributes}}
    {{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- template "bulkStructFieldsTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- else if eq .Type "list"}}
	{{toGoName .TfName}} []{{$typePrefix}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end bulkStructFieldsTemplate ==================== */}}

{{- /* ==================== bulkChildStructTypesTemplate ====================
       Recursively declares struct types for list-type TfChildClasses.
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "bulkChildStructTypesTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}

type {{$typePrefix}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- template "bulkStructFieldsTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
}
{{- end}}
{{- if .TfChildClasses}}
{{- template "bulkChildStructTypesTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end bulkChildStructTypesTemplate ==================== */}}

type {{camelCase .BulkName}}Items struct {
{{- range .Attributes}}
{{- if not .ReferenceOnly}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- template "bulkStructFieldsTemplate" (makeMap "TypePrefix" $bulkName "Children" .TfChildClasses)}}
}
{{- template "bulkChildStructTypesTemplate" (makeMap "TypePrefix" $bulkName "Children" .TfChildClasses)}}


type {{camelCase .BulkName}}Identity struct {
	Device types.String `tfsdk:"device"`
{{- range (bulkImportAttributes .)}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
}

func (data *{{camelCase .BulkName}}Identity) toIdentity(ctx context.Context, plan *{{camelCase .BulkName}}) {
	if plan.Device.IsNull() {
		data.Device = types.StringValue("")
	} else {
		data.Device = plan.Device
	}
{{- range (bulkImportAttributes .)}}
	data.{{toGoName .TfName}} = types.StringNull()
{{- end}}
}

func (data *{{camelCase .BulkName}}) fromIdentity(ctx context.Context, identity *{{camelCase .BulkName}}Identity) {
	if identity.Device.ValueString() == "" {
		data.Device = types.StringNull()
	} else {
		data.Device = identity.Device
	}
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data {{camelCase .BulkName}}) getDn() string {
	return "{{parentDn .Dn}}"
}

func (data {{camelCase .BulkName}}) getClassName() string {
	return "{{.ParentClassName}}"
}

func (data {{camelCase .BulkName}}) getItemClassName() string {
	return "{{.ClassName}}"
}

func (data {{camelCase .BulkName}}) getItemDn(item {{camelCase .BulkName}}Items) string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Dn}}"{{range .Attributes}}{{if .Id}}, item.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{.Dn}}"
{{- end}}
}

func (data {{camelCase .BulkName}}) getItemRn(item {{camelCase .BulkName}}Items) string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{childRn .Dn}}"{{range .Attributes}}{{if .Id}}, item.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{childRn .Dn}}"
{{- end}}
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data {{camelCase .BulkName}}) toBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	childrenPath := data.getClassName() + ".children"

	for _, item := range data.Items {
		itemBody := ""
		itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes", map[string]interface{}{})
		{{- range .Attributes}}
		{{- if not .ReferenceOnly}}
		if (!item.{{toGoName .TfName}}.IsUnknown() && !item.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
			{{- if eq .Type "Int64"}}
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"{{.NxosName}}", strconv.FormatInt(item.{{toGoName .TfName}}.ValueInt64(), 10))
			{{- else if eq .Type "Bool"}}
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"{{.NxosName}}", strconv.FormatBool(item.{{toGoName .TfName}}.ValueBool()))
			{{- else if eq .Type "String"}}
			itemBody, _ = sjson.Set(itemBody, data.getItemClassName()+".attributes."+"{{.NxosName}}", item.{{toGoName .TfName}}.ValueString())
			{{- end}}
		}
		{{- end}}
		{{- end}}

		{{- if .ChildClasses}}
		var attrs string
		itemChildrenPath := data.getItemClassName() + ".children"
		{{- template "bulkToBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" "item" "ChildrenPathVar" "itemChildrenPath" "BodyVar" "itemBody" "RnArgs" "")}}
		_ = attrs
		{{- end}}

		body, _ = sjson.SetRaw(body, childrenPath+".-1", itemBody)
	}

	return nxos.Body{body}
}

{{- /* ==================== bulkToBodyChildrenTemplate ====================
       Recursively generates sjson body-building code for child classes within bulk items.
       ========================================================= */}}
{{- define "bulkToBodyChildrenTemplate"}}
{{- $dataVar := .DataVar}}
{{- $childrenPathVar := .ChildrenPathVar}}
{{- $bodyVar := .BodyVar}}
{{- $rnArgs := .RnArgs}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childAlwaysInclude := .AlwaysInclude}}
{{- $childRn := .Rn}}
{{- if eq .Type "single"}}
	attrs = "{}"
	{{- range .Attributes}}
	{{- if .Value}}
	attrs, _ = sjson.Set(attrs, "{{.NxosName}}", "{{.Value}}")
	{{- else if not .ReferenceOnly}}
	if (!{{$dataVar}}.{{toGoName .TfName}}.IsUnknown() && !{{$dataVar}}.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt({{$dataVar}}.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool({{$dataVar}}.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", {{$dataVar}}.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	if attrs != "{}" || {{$childAlwaysInclude}} {
		{{$bodyVar}}, _ = sjson.SetRaw({{$bodyVar}}, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
	}
{{- else if eq .Type "list"}}
	for _, child := range {{$dataVar}}.{{toGoName .TfName}} {
		attrs = "{}"
		{{- range .Attributes}}
		if (!child.{{toGoName .TfName}}.IsUnknown() && !child.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
			{{- if eq .Type "Int64"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt(child.{{toGoName .TfName}}.ValueInt64(), 10))
			{{- else if eq .Type "Bool"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool(child.{{toGoName .TfName}}.ValueBool()))
			{{- else if eq .Type "String"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", child.{{toGoName .TfName}}.ValueString())
			{{- end}}
		}
		{{- end}}
		{{$bodyVar}}, _ = sjson.SetRaw({{$bodyVar}}, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end bulkToBodyChildrenTemplate ==================== */}}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *{{camelCase .BulkName}}) fromBody(res gjson.Result) {
	data.Items = make([]{{camelCase .BulkName}}Items, 0)
	res.Get(data.getClassName() + ".children").ForEach(func(_, v gjson.Result) bool {
		v.ForEach(func(classname, value gjson.Result) bool {
			if classname.String() == data.getItemClassName() {
				item := {{camelCase .BulkName}}Items{}
				{{- range .Attributes}}
				{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
				{{- if eq .Type "Int64"}}
				item.{{toGoName .TfName}} = types.Int64Value(value.Get("attributes.{{.NxosName}}").Int())
				{{- else if eq .Type "Bool"}}
				item.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.{{.NxosName}}").String()))
				{{- else if eq .Type "String"}}
				item.{{toGoName .TfName}} = types.StringValue(value.Get("attributes.{{.NxosName}}").String())
				{{- end}}
				{{- end}}
				{{- end}}
				{{- if .ChildClasses}}
				{{- template "bulkFromBodyChildrenTemplate" (makeMap "TypePrefix" $bulkName "Children" .ChildClasses "ValueVar" "value" "ParentVar" "item")}}
				{{- end}}
				data.Items = append(data.Items, item)
			}
			return true
		})
		return true
	})
}

{{- /* ==================== bulkFromBodyChildrenTemplate ====================
       Recursively generates gjson parsing for children of bulk items.
       ========================================================= */}}
{{- define "bulkFromBodyChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $valueVar := .ValueVar}}
{{- $parentVar := .ParentVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- if eq .Type "single"}}
	{
	var r{{$childClassName}} gjson.Result
	{{$valueVar}}.Get("children").ForEach(
		func(_, nestedV gjson.Result) bool {
			key := nestedV.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{.Rn}}" {
				r{{$childClassName}} = nestedV
				return false
			}
			return true
		},
	)
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	{{$parentVar}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
	{{- else if eq .Type "Bool"}}
	{{$parentVar}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
	{{- else if eq .Type "String"}}
	{{$parentVar}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
	{{- end}}
	{{- end}}
	{{- end}}
	}
{{- else if eq .Type "list"}}
	{{$valueVar}}.Get("children").ForEach(
		func(_, nestedV gjson.Result) bool {
			nestedV.ForEach(
				func(nestedClassname, nestedValue gjson.Result) bool {
					if nestedClassname.String() == "{{$childClassName}}" {
						var nestedChild {{$typePrefix}}{{toGoName .TfName}}
						{{- range .Attributes}}
						{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
						{{- if eq .Type "Int64"}}
						nestedChild.{{toGoName .TfName}} = types.Int64Value(nestedValue.Get("attributes.{{.NxosName}}").Int())
						{{- else if eq .Type "Bool"}}
						nestedChild.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(nestedValue.Get("attributes.{{.NxosName}}").String()))
						{{- else if eq .Type "String"}}
						nestedChild.{{toGoName .TfName}} = types.StringValue(nestedValue.Get("attributes.{{.NxosName}}").String())
						{{- end}}
						{{- end}}
						{{- end}}
						{{$parentVar}}.{{toGoName .TfName}} = append({{$parentVar}}.{{toGoName .TfName}}, nestedChild)
					}
					return true
				},
			)
			return true
		},
	)
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end bulkFromBodyChildrenTemplate ==================== */}}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *{{camelCase .BulkName}}) updateFromBody(res gjson.Result) {
	for i := range data.Items {
		// Find the matching item in the response by id attributes
		res.Get(data.getClassName() + ".children").ForEach(func(_, v gjson.Result) bool {
			v.ForEach(func(classname, value gjson.Result) bool {
				if classname.String() == data.getItemClassName() {
					{{- range (bulkIdAttributes .)}}
					{{- if eq .Type "String"}}
					if value.Get("attributes.{{.NxosName}}").String() != data.Items[i].{{toGoName .TfName}}.ValueString() {
						return true
					}
					{{- else if eq .Type "Int64"}}
					if value.Get("attributes.{{.NxosName}}").Int() != data.Items[i].{{toGoName .TfName}}.ValueInt64() {
						return true
					}
					{{- end}}
					{{- end}}
					// Found matching item, update attributes
					{{- range .Attributes}}
					{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
					if !data.Items[i].{{toGoName .TfName}}.IsNull() {
						{{- if eq .Type "Int64"}}
						data.Items[i].{{toGoName .TfName}} = types.Int64Value(value.Get("attributes.{{.NxosName}}").Int())
						{{- else if eq .Type "Bool"}}
						data.Items[i].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.{{.NxosName}}").String()))
						{{- else if eq .Type "String"}}
						data.Items[i].{{toGoName .TfName}} = types.StringValue(value.Get("attributes.{{.NxosName}}").String())
						{{- end}}
					} else {
						data.Items[i].{{toGoName .TfName}} = types.{{.Type}}Null()
					}
					{{- end}}
					{{- end}}
					{{- if .ChildClasses}}
					{{- template "bulkUpdateFromBodyChildrenTemplate" (makeMap "TypePrefix" $bulkName "Children" .ChildClasses "ValueVar" "value" "DataExpr" (printf "data.Items[i]"))}}
					{{- end}}
				}
				return true
			})
			return true
		})
	}
}

{{- /* ==================== bulkUpdateFromBodyChildrenTemplate ==================== */}}
{{- define "bulkUpdateFromBodyChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $valueVar := .ValueVar}}
{{- $dataExpr := .DataExpr}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- if eq .Type "single"}}
	{
	var r{{$childClassName}} gjson.Result
	{{$valueVar}}.Get("children").ForEach(
		func(_, nestedV gjson.Result) bool {
			key := nestedV.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{.Rn}}" {
				r{{$childClassName}} = nestedV
				return false
			}
			return true
		},
	)
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !{{$dataExpr}}.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		{{$dataExpr}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		{{$dataExpr}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		{{$dataExpr}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		{{$dataExpr}}.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	}
{{- else if eq .Type "list"}}
	for c := range {{$dataExpr}}.{{toGoName .TfName}} {
		var r{{$childClassName}} gjson.Result
		{{$valueVar}}.Get("children").ForEach(
			func(_, nestedV gjson.Result) bool {
				key := nestedV.Get("{{$childClassName}}.attributes.rn").String()
				if key == {{$dataExpr}}.{{toGoName .TfName}}[c].getRn() {
					r{{$childClassName}} = nestedV
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !{{$dataExpr}}.{{toGoName .TfName}}[c].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			{{$dataExpr}}.{{toGoName .TfName}}[c].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			{{$dataExpr}}.{{toGoName .TfName}}[c].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			{{$dataExpr}}.{{toGoName .TfName}}[c].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			{{$dataExpr}}.{{toGoName .TfName}}[c].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end bulkUpdateFromBodyChildrenTemplate ==================== */}}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data {{camelCase .BulkName}}) getDeletedItems(ctx context.Context, state {{camelCase .BulkName}}) []string {
	var deletedItems []string
	for _, stateItem := range state.Items {
		found := false
		for _, planItem := range data.Items {
			{{- range (bulkIdAttributes .)}}
			{{- if eq .Type "String"}}
			if planItem.{{toGoName .TfName}}.ValueString() != stateItem.{{toGoName .TfName}}.ValueString() {
				continue
			}
			{{- else if eq .Type "Int64"}}
			if planItem.{{toGoName .TfName}}.ValueInt64() != stateItem.{{toGoName .TfName}}.ValueInt64() {
				continue
			}
			{{- end}}
			{{- end}}
			found = true
			break
		}
		if !found {
			deletedItems = append(deletedItems, data.getItemDn(stateItem))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
