//go:build ignore
// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-nxos"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"github.com/CiscoDevNet/terraform-provider-nxos/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

{{- /* ==================== structFieldsTemplate ====================
       Recursively emits struct fields for TfChildClasses.
       - single: flatten attributes into parent struct, recurse
       - list: emit slice field, recurse
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "structFieldsTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "single"}}
{{- range .Attributes}}
    {{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- else if eq .Type "list"}}
	{{toGoName .TfName}} []{{$typePrefix}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end structFieldsTemplate ==================== */}}

{{- /* ==================== childStructTypesTemplate ====================
       Recursively declares struct types for list-type TfChildClasses.
       Context: map with "TypePrefix" (string) and "Children" ([]TfChildClass)
       ========================================================= */}}
{{- define "childStructTypesTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}

type {{$typePrefix}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- if .TfChildClasses}}
{{- $childTypePrefix := printf "%s%s" $typePrefix (toGoName .TfName)}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $childTypePrefix "Children" .TfChildClasses)}}
{{- end}}
}
{{- end}}
{{- if .TfChildClasses}}
{{- if eq .Type "list"}}
{{- template "childStructTypesTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .TfChildClasses)}}
{{- else}}
{{- template "childStructTypesTemplate" (makeMap "TypePrefix" $typePrefix "Children" .TfChildClasses)}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end childStructTypesTemplate ==================== */}}

{{ $name := camelCase .Name}}
type {{camelCase .Name}} struct {
	Device types.String `tfsdk:"device"`
	Dn types.String `tfsdk:"id"`
{{- range .Attributes}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- template "structFieldsTemplate" (makeMap "TypePrefix" $name "Children" .TfChildClasses)}}
}
{{- template "childStructTypesTemplate" (makeMap "TypePrefix" $name "Children" .TfChildClasses)}}


type {{camelCase .Name}}Identity struct {
	Device types.String `tfsdk:"device"`
{{- range (importAttributes .)}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
}

func (data *{{camelCase .Name}}Identity) toIdentity(ctx context.Context, plan *{{camelCase .Name}}) {
	if plan.Device.IsNull() {
		data.Device = types.StringValue("")
	} else {
		data.Device = plan.Device
	}
{{- range (importAttributes .)}}
	data.{{toGoName .TfName}} = plan.{{toGoName .TfName}}
{{- end}}
}

func (data *{{camelCase .Name}}) fromIdentity(ctx context.Context, identity *{{camelCase .Name}}Identity) {
	if identity.Device.ValueString() == "" {
		data.Device = types.StringNull()
	} else {
		data.Device = identity.Device
	}
{{- range (importAttributes .)}}
	data.{{toGoName .TfName}} = identity.{{toGoName .TfName}}
{{- end}}
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data {{camelCase .Name}}) getDn() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Dn}}"{{range .Attributes}}{{if .Id}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{.Dn}}"
{{- end}}
}

{{- /* ==================== getRnTemplate ====================
       Recursively generates getRn() methods for all list-type child classes.
       Context: map with "TypePrefix" (string) and "Children" ([]YamlConfigChildClass)
       ========================================================= */}}
{{- define "getRnTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- range .Children}}
{{- if eq .Type "list"}}

func (data {{$typePrefix}}{{toGoName .TfName}}) getRn() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Rn}}"{{range .Attributes}}{{if .Id}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{.Rn}}"
{{- end}}
}
{{- end}}
{{- if .ChildClasses}}
{{- if eq .Type "list"}}
{{- template "getRnTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .ChildClasses)}}
{{- else}}
{{- template "getRnTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses)}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end getRnTemplate ==================== */}}

{{- template "getRnTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses)}}

func (data {{camelCase .Name}}) getClassName() string {
	return "{{.ClassName}}"
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

{{- /* ==================== toBodyChildrenTemplate ====================
       Recursively generates sjson body-building code for child classes.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "DataVar" (string) - Go variable holding data (e.g. "data", "child")
         "ChildrenPathVar" (string) - Go variable name holding the sjson path to the children array
         "RnArgs" (string) - pre-computed fmt.Sprintf args for dynamic RN segments
       ========================================================= */}}
{{- define "toBodyChildrenTemplate"}}
{{- $dataVar := .DataVar}}
{{- $childrenPathVar := .ChildrenPathVar}}
{{- $rnArgs := .RnArgs}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childAlwaysInclude := .AlwaysInclude}}
{{- $childRn := .Rn}}
{{- if eq .Type "single"}}
{{- if .ChildClasses}}
	{
	childIndex := len(gjson.Get(body, {{$childrenPathVar}}).Array())
	childBodyPath := {{$childrenPathVar}} + "." + strconv.Itoa(childIndex) + ".{{$childClassName}}"
	attrs = "{}"
	{{- if rnHasDynamicSegment $childRn}}
	attrs, _ = sjson.Set(attrs, "name", {{$rnArgs}})
	{{- end}}
	{{- range .Attributes}}
	{{- if .Value}}
	attrs, _ = sjson.Set(attrs, "{{.NxosName}}", "{{.Value}}")
	{{- else if not .ReferenceOnly}}
	if (!{{$dataVar}}.{{toGoName .TfName}}.IsUnknown() && !{{$dataVar}}.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt({{$dataVar}}.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool({{$dataVar}}.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", {{$dataVar}}.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	body, _ = sjson.SetRaw(body, childBodyPath+".attributes", attrs)
	nestedChildrenPath := childBodyPath + ".children"
	{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" $dataVar "ChildrenPathVar" "nestedChildrenPath" "RnArgs" $rnArgs)}}
	}
{{- else}}
	attrs = "{}"
	{{- if rnHasDynamicSegment $childRn}}
	attrs, _ = sjson.Set(attrs, "name", {{$rnArgs}})
	{{- end}}
	{{- range .Attributes}}
	{{- if .Value}}
	attrs, _ = sjson.Set(attrs, "{{.NxosName}}", "{{.Value}}")
	{{- else if not .ReferenceOnly}}
	if (!{{$dataVar}}.{{toGoName .TfName}}.IsUnknown() && !{{$dataVar}}.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt({{$dataVar}}.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool({{$dataVar}}.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		attrs, _ = sjson.Set(attrs, "{{.NxosName}}", {{$dataVar}}.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	if attrs != "{}" || {{$childAlwaysInclude}} {
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
	}
{{- end}}
{{- else if eq .Type "list"}}
	for _, child := range {{$dataVar}}.{{toGoName .TfName}} {
		attrs = "{}"
		{{- range .Attributes}}
		if (!child.{{toGoName .TfName}}.IsUnknown() && !child.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
			{{- if eq .Type "Int64"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatInt(child.{{toGoName .TfName}}.ValueInt64(), 10))
			{{- else if eq .Type "Bool"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", strconv.FormatBool(child.{{toGoName .TfName}}.ValueBool()))
			{{- else if eq .Type "String"}}
			attrs, _ = sjson.Set(attrs, "{{.NxosName}}", child.{{toGoName .TfName}}.ValueString())
			{{- end}}
		}
		{{- end}}
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1.{{$childClassName}}.attributes", attrs)
		{{- if .ChildClasses}}
		{
		nestedIndex := len(gjson.Get(body, {{$childrenPathVar}}).Array()) - 1
		nestedChildrenPath := {{$childrenPathVar}} + "." + strconv.Itoa(nestedIndex) + ".{{$childClassName}}.children"
		{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" "child" "ChildrenPathVar" "nestedChildrenPath" "RnArgs" $rnArgs)}}
		}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toBodyChildrenTemplate ==================== */}}

func (data {{camelCase .Name}}) toBody() nxos.Body {
	body := ""
	body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	{{- range .Attributes}}
	{{- if not .ReferenceOnly}}
	if (!data.{{toGoName .TfName}}.IsUnknown() && !data.{{toGoName .TfName}}.IsNull()) || {{.AlwaysInclude}} {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatInt(data.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatBool(data.{{toGoName .TfName}}.ValueBool()))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", data.{{toGoName .TfName}}.ValueString())
		{{- end}}
	}
	{{- end}}
	{{- end}}

	{{- if .ChildClasses}}
	var attrs string
	childrenPath := data.getClassName() + ".children"
	{{- template "toBodyChildrenTemplate" (makeMap "Children" .ChildClasses "DataVar" "data" "ChildrenPathVar" "childrenPath" "RnArgs" (rnFormatArgs "data" .Attributes))}}
	{{- end}}

	return nxos.Body{body}
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

{{- /* ==================== fromBodyChildrenTemplate ====================
       Recursively generates gjson parsing code for child classes in fromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for the parent gjson result
         "DataVar" (string) - Go expression for data accessor (e.g. "data", "child")
         "RnArgs" (string) - pre-computed fmt.Sprintf args for dynamic RN segments
       ========================================================= */}}
{{- define "fromBodyChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataVar := .DataVar}}
{{- $rnArgs := .RnArgs}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- if or (len .Attributes) .ChildClasses}}
{{- if eq .Type "single"}}
{{- $hasNonRefAttribs := false}}
{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
{{- if or $hasNonRefAttribs .ChildClasses}}
	{
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			{{- if rnHasDynamicSegment $childRn}}
			if key == fmt.Sprintf("{{$childRn}}", {{$rnArgs}}) {
			{{- else}}
			if key == "{{$childRn}}" {
			{{- end}}
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
{{- end}}
{{- range .Attributes}}
{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
{{- if eq .Type "Int64"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
{{- else if eq .Type "Bool"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
{{- else if eq .Type "String"}}
	{{$dataVar}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
{{- end}}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
	{{- template "fromBodyChildrenTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataVar" $dataVar "RnArgs" $rnArgs)}}
{{- end}}
	}
{{- else if eq .Type "list"}}
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			v.ForEach(
				func(classname, value gjson.Result) bool {
					if classname.String() == "{{$childClassName}}" {
						var child {{$typePrefix}}{{toGoName .TfName}}
						{{- range .Attributes}}
						{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
						{{- if eq .Type "Int64"}}
						child.{{toGoName .TfName}} = types.Int64Value(value.Get("attributes.{{.NxosName}}").Int())
						{{- else if eq .Type "Bool"}}
						child.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(value.Get("attributes.{{.NxosName}}").String()))
						{{- else if eq .Type "String"}}
						child.{{toGoName .TfName}} = types.StringValue(value.Get("attributes.{{.NxosName}}").String())
						{{- end}}
						{{- end}}
						{{- end}}
						{{- if .ChildClasses}}
						{{- template "fromBodyListChildrenTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .ChildClasses "ValueVar" "value" "ParentVar" "child")}}
						{{- end}}
						{{$dataVar}}.{{toGoName .TfName}} = append({{$dataVar}}.{{toGoName .TfName}}, child)
					}
					return true
				},
			)
			return true
		},
	)
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end fromBodyChildrenTemplate ==================== */}}

{{- /* ==================== fromBodyListChildrenTemplate ====================
       Recursively generates gjson parsing code for children of list-type parents
       in fromBody. Inside a ForEach callback, the value variable is unwrapped.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ValueVar" (string) - Go variable for parent's gjson value
         "ParentVar" (string) - Go variable for the parent struct being built
       ========================================================= */}}
{{- define "fromBodyListChildrenTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $valueVar := .ValueVar}}
{{- $parentVar := .ParentVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- if eq .Type "single"}}
						{
						var r{{$childClassName}} gjson.Result
						{{$valueVar}}.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								key := nestedV.Get("{{$childClassName}}.attributes.rn").String()
								if key == "{{$childRn}}" {
									r{{$childClassName}} = nestedV
									return false
								}
								return true
							},
						)
						{{- range .Attributes}}
						{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
						{{- if eq .Type "Int64"}}
						{{$parentVar}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
						{{- else if eq .Type "Bool"}}
						{{$parentVar}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
						{{- else if eq .Type "String"}}
						{{$parentVar}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
						{{- end}}
						{{- end}}
						{{- end}}
						{{- if .ChildClasses}}
						{{- template "fromBodyListChildrenTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ValueVar" (printf "r%s.Get(\"%s\")" $childClassName $childClassName) "ParentVar" $parentVar)}}
						{{- end}}
						}
{{- else if eq .Type "list"}}
						{{$valueVar}}.Get("children").ForEach(
							func(_, nestedV gjson.Result) bool {
								nestedV.ForEach(
									func(nestedClassname, nestedValue gjson.Result) bool {
										if nestedClassname.String() == "{{$childClassName}}" {
											var nestedChild{{$childClassName}} {{$typePrefix}}{{toGoName .TfName}}
											{{- range .Attributes}}
											{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
											{{- if eq .Type "Int64"}}
											nestedChild{{$childClassName}}.{{toGoName .TfName}} = types.Int64Value(nestedValue.Get("attributes.{{.NxosName}}").Int())
											{{- else if eq .Type "Bool"}}
											nestedChild{{$childClassName}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(nestedValue.Get("attributes.{{.NxosName}}").String()))
											{{- else if eq .Type "String"}}
											nestedChild{{$childClassName}}.{{toGoName .TfName}} = types.StringValue(nestedValue.Get("attributes.{{.NxosName}}").String())
											{{- end}}
											{{- end}}
											{{- end}}
											{{- if .ChildClasses}}
											{{- template "fromBodyListChildrenTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .ChildClasses "ValueVar" "nestedValue" "ParentVar" (printf "nestedChild%s" $childClassName))}}
											{{- end}}
											{{$parentVar}}.{{toGoName .TfName}} = append({{$parentVar}}.{{toGoName .TfName}}, nestedChild{{$childClassName}})
										}
										return true
									},
								)
								return true
							},
						)
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end fromBodyListChildrenTemplate ==================== */}}

func (data *{{camelCase .Name}}) fromBody(res gjson.Result) {
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	data.{{toGoName .TfName}} = types.Int64Value(res.Get(data.getClassName()+".attributes.{{.NxosName}}").Int())
	{{- else if eq .Type "Bool"}}
	data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String()))
	{{- else if eq .Type "String"}}
	data.{{toGoName .TfName}} = types.StringValue(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String())
	{{- end}}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "fromBodyChildrenTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses "ResExpr" (printf "res.Get(data.getClassName() + \".children\")") "DataVar" "data" "RnArgs" (rnFormatArgs "data" .Attributes))}}
	{{- end}}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

{{- /* ==================== updateFromBodySingleChildTemplate ====================
       Recursively generates update code for single-type children in updateFromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix for struct names
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for parent result's children
         "DataAccessor" (string) - Go expression prefix for data access
         "RnArgs" (string) - pre-computed fmt.Sprintf args for dynamic RN segments
       ========================================================= */}}
{{- define "updateFromBodySingleChildTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataAccessor := .DataAccessor}}
{{- $rnArgs := .RnArgs}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- $list := (toGoName .TfName)}}
{{- if eq .Type "single"}}
{{- $hasNonRefAttribs := false}}
{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
{{- $hasChildren := false}}
{{- if .ChildClasses}}{{$hasChildren = true}}{{end}}
{{- if or $hasNonRefAttribs $hasChildren}}
	{
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			{{- if rnHasDynamicSegment $childRn}}
			if key == fmt.Sprintf("{{$childRn}}", {{$rnArgs}}) {
			{{- else}}
			if key == "{{$childRn}}" {
			{{- end}}
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
{{- end}}
{{- range .Attributes}}
{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !{{$dataAccessor}}.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		{{$dataAccessor}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		{{$dataAccessor}}.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
	{{- template "updateFromBodySingleChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataAccessor" $dataAccessor "RnArgs" $rnArgs)}}
{{- end}}
{{- if or $hasNonRefAttribs $hasChildren}}
	}
{{- end}}
{{- else if eq .Type "list"}}
	for c := range {{$dataAccessor}}.{{$list}} {
		var r{{$childClassName}} gjson.Result
		{{$resExpr}}.ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == {{$dataAccessor}}.{{$list}}[c].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			{{$dataAccessor}}.{{$list}}[c].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "%s.%s[c]" $dataAccessor $list) "IndexVar" "nc")}}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end updateFromBodySingleChildTemplate ==================== */}}

{{- /* ==================== updateFromBodyListChildTemplate ====================
       Recursively generates update code for list-type children in updateFromBody.
       Context: map with:
         "TypePrefix" (string) - Go type prefix
         "Children" ([]YamlConfigChildClass)
         "ResExpr" (string) - Go expression for parent result's children
         "DataListExpr" (string) - Go expression for data list (e.g. "data.Interfaces")
         "IndexVar" (string) - Loop index variable name
       ========================================================= */}}
{{- define "updateFromBodyListChildTemplate"}}
{{- $typePrefix := .TypePrefix}}
{{- $resExpr := .ResExpr}}
{{- $dataListExpr := .DataListExpr}}
{{- $indexVar := .IndexVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- $childRn := .Rn}}
{{- $list := (toGoName .TfName)}}
{{- if eq .Type "single"}}
	{
	var r{{$childClassName}} gjson.Result
	{{$resExpr}}.ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			if key == "{{$childRn}}" {
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !{{$dataListExpr}}.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		{{$dataListExpr}}.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		{{$dataListExpr}}.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" $typePrefix "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" $dataListExpr "IndexVar" $indexVar)}}
	{{- end}}
	}
{{- else if eq .Type "list"}}
	for {{$indexVar}} := range {{$dataListExpr}}.{{$list}} {
		var r{{$childClassName}} gjson.Result
		{{$resExpr}}.ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == {{$dataListExpr}}.{{$list}}[{{$indexVar}}].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			{{$dataListExpr}}.{{$list}}[{{$indexVar}}].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" (printf "%s%s" $typePrefix (toGoName .TfName)) "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "%s.%s[%s]" $dataListExpr $list $indexVar) "IndexVar" (printf "%s_" $indexVar))}}
		{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end updateFromBodyListChildTemplate ==================== */}}

func (data *{{camelCase .Name}}) updateFromBody(res gjson.Result) {
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		data.{{toGoName .TfName}} = types.Int64Value(res.Get(data.getClassName()+".attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		data.{{toGoName .TfName}} = types.StringValue(res.Get(data.getClassName()+".attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- range .ChildClasses}}
	{{- $childClassName := .ClassName}}
	{{- $childRn := .Rn}}
	{{- $list := (toGoName .TfName)}}
	{{- if eq .Type "single"}}
	{{- $hasNonRefAttribs := false}}
	{{- range .Attributes}}{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}{{$hasNonRefAttribs = true}}{{end}}{{end}}
	{{- $hasChildren := false}}
	{{- if .ChildClasses}}{{$hasChildren = true}}{{end}}
	{{- if or $hasNonRefAttribs $hasChildren}}
	var r{{$childClassName}} gjson.Result
	res.Get(data.getClassName() + ".children").ForEach(
		func(_, v gjson.Result) bool {
			key := v.Get("{{$childClassName}}.attributes.rn").String()
			{{- if rnHasDynamicSegment $childRn}}
			if key == fmt.Sprintf("{{$childRn}}", {{rnFormatArgs "data" $.Attributes}}) {
			{{- else}}
			if key == "{{$childRn}}" {
			{{- end}}
				r{{$childClassName}} = v
				return false
			}
			return true
		},
	)
	{{- end}}
	{{- range .Attributes}}
	{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		data.{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
		{{- else if eq .Type "Bool"}}
		data.{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
		{{- else if eq .Type "String"}}
		data.{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
	{{- end}}
	{{- end}}
	{{- if .ChildClasses}}
	{{- template "updateFromBodySingleChildTemplate" (makeMap "TypePrefix" $name "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataAccessor" "data" "RnArgs" (rnFormatArgs "data" $.Attributes))}}
	{{- end}}
	{{- else if eq .Type "list"}}
	for c := range data.{{toGoName .TfName}} {
		var r{{$childClassName}} gjson.Result
		res.Get(data.getClassName() + ".children").ForEach(
			func(_, v gjson.Result) bool {
				key := v.Get("{{$childClassName}}.attributes.rn").String()
				if key == data.{{$list}}[c].getRn() {
					r{{$childClassName}} = v
					return false
				}
				return true
			},
		)
		{{- range .Attributes}}
		{{- if and (not .Value) (not .ReferenceOnly) (not .WriteOnly)}}
		if !data.{{$list}}[c].{{toGoName .TfName}}.IsNull() {
			{{- if eq .Type "Int64"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.Int64Value(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").Int())
			{{- else if eq .Type "Bool"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.BoolValue(helpers.ParseNxosBoolean(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String()))
			{{- else if eq .Type "String"}}
			data.{{$list}}[c].{{toGoName .TfName}} = types.StringValue(r{{$childClassName}}.Get("{{$childClassName}}.attributes.{{.NxosName}}").String())
			{{- end}}
		} else {
			data.{{$list}}[c].{{toGoName .TfName}} = types.{{.Type}}Null()
		}
		{{- end}}
		{{- end}}
		{{- if .ChildClasses}}
		{{- template "updateFromBodyListChildTemplate" (makeMap "TypePrefix" (printf "%s%s" $name (toGoName .TfName)) "Children" .ChildClasses "ResExpr" (printf "r%s.Get(\"%s.children\")" $childClassName $childClassName) "DataListExpr" (printf "data.%s[c]" $list) "IndexVar" "nc")}}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin toDeleteBody

{{- /* ==================== toDeleteBodyChildrenTemplate ====================
       Recursively generates sjson body-building code for child classes in toDeleteBody.
       Uses dynamic index calculation (matching toBody's approach) to ensure each
       top-level child class gets its own children array index.
       For each child:
         - NoDelete children with sub-children: create entry, set delete_value attrs, recurse
         - NoDelete leaf children: create entry, set delete_value attrs
         - Deletable single children: append delete entry
         - Deletable list children: append delete entries per item
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "ChildrenPathVar" (string) - Go variable name holding the sjson path to the children array
       ========================================================= */}}
{{- define "toDeleteBodyChildrenTemplate"}}
{{- $childrenPathVar := .ChildrenPathVar}}
{{- range .Children}}
{{- $childClassName := .ClassName}}
{{- if .NoDelete}}
{{- if eq .Type "single"}}
	{
	childIndex := len(gjson.Get(body, {{$childrenPathVar}}).Array())
	childBodyPath := {{$childrenPathVar}} + "." + strconv.Itoa(childIndex) + ".{{$childClassName}}"
	body, _ = sjson.SetRaw(body, childBodyPath+".attributes", "{}")
{{- range .Attributes}}
{{- if and (not .ReferenceOnly) (.DeleteValue)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, childBodyPath+".attributes."+"{{.NxosName}}", strconv.FormatInt({{ .DeleteValue}}, 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, childBodyPath+".attributes."+"{{.NxosName}}", strconv.FormatBool({{ .DeleteValue}}))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, childBodyPath+".attributes."+"{{.NxosName}}", "{{ .DeleteValue}}")
		{{- end}}
	}
{{- end}}
{{- end}}
{{- if .ChildClasses}}
	nestedChildrenPath := childBodyPath + ".children"
	_ = nestedChildrenPath
	{{- template "toDeleteBodyChildrenTemplate" (makeMap "Children" .ChildClasses "ChildrenPathVar" "nestedChildrenPath")}}
{{- end}}
	}
{{- end}}
{{- else}}
{{- if eq .Type "single"}}
	{
		deleteBody := ""
		deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.rn", "{{.Rn}}")
		deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.status", "deleted")
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1", deleteBody)
	}
{{- else if eq .Type "list"}}
	for _, child := range data.{{toGoName .TfName}} {
		deleteBody := ""
		deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.rn", child.getRn())
		deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.status", "deleted")
		body, _ = sjson.SetRaw(body, {{$childrenPathVar}}+".-1", deleteBody)
	}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toDeleteBodyChildrenTemplate ==================== */}}

func (data {{camelCase .Name}}) toDeleteBody() nxos.Body {
	body := ""

	{{- if not .NoDelete}}
	body, _ = sjson.Set(body, data.getClassName()+".attributes.status", "deleted")
	{{- else}}
	{{- range .Attributes}}
	{{- if and (not .ReferenceOnly) (.DeleteValue)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatInt({{ .DeleteValue}}, 10))
		{{- else if eq .Type "Bool"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", strconv.FormatBool({{ .DeleteValue}}))
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, data.getClassName()+".attributes."+"{{.NxosName}}", "{{ .DeleteValue}}")
		{{- end}}
	}
	{{- end}}
	{{- end}}
	if body == "" {
		body, _ = sjson.Set(body, data.getClassName()+".attributes", map[string]interface{}{})
	}
	{{- if .ChildClasses}}
	childrenPath := data.getClassName() + ".children"
	{{- template "toDeleteBodyChildrenTemplate" (makeMap "Children" .ChildClasses "ChildrenPathVar" "childrenPath")}}
	{{- end}}
	{{- end}}

	return nxos.Body{body}
}

{{- /* ==================== toBodyDeletedSingleInListTemplate ====================
       Detects deleted items within single-type children of matched list-item pairs
       and appends delete entries to the body.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "StateItemExpr" (string) - Go expression for a single state item
         "PlanItemExpr" (string) - Go expression for a single plan item
         "ParentBodyPath" (string) - Go expression for the parent body path
         "IndexVar" (string) - Loop index variable name
       ========================================================= */}}
{{- define "toBodyDeletedSingleInListTemplate"}}
{{- $stateItemExpr := .StateItemExpr}}
{{- $planItemExpr := .PlanItemExpr}}
{{- $parentBodyPath := .ParentBodyPath}}
{{- $indexVar := .IndexVar}}
{{- range .Children}}
{{- if eq .Type "list"}}
			for _, stateChild := range {{$stateItemExpr}}.{{toGoName .TfName}} {
				found := false
				for _, planChild := range {{$planItemExpr}}.{{toGoName .TfName}} {
					if {{range $i, $a := .Attributes}}{{if $a.Id}}{{if $i}} && {{end}}stateChild.{{toGoName $a.TfName}} == planChild.{{toGoName $a.TfName}}{{end}}{{end}} {
						found = true
						break
					}
				}
				if !found {
					deleteBody := ""
					deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.rn", stateChild.getRn())
					deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.status", "deleted")
					body.Str, _ = sjson.SetRaw(body.Str, {{$parentBodyPath}}+".-1", deleteBody)
				}
			}
{{- if .ChildClasses}}
{{- template "toBodyDeletedListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "%s.%s" $stateItemExpr (toGoName .TfName)) "PlanListExpr" (printf "%s.%s" $planItemExpr (toGoName .TfName)) "ParentBodyPath" $parentBodyPath "IdAttributes" .Attributes "ClassName" .ClassName "IndexVar" (printf "%s_" $indexVar))}}
{{- end}}
{{- else if eq .Type "single"}}
{{- if .ChildClasses}}
{{- template "toBodyDeletedSingleInListTemplate" (makeMap "Children" .ChildClasses "StateItemExpr" $stateItemExpr "PlanItemExpr" $planItemExpr "ParentBodyPath" (printf "%s+\".0.%s.children\"" $parentBodyPath .ClassName) "IndexVar" $indexVar)}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toBodyDeletedSingleInListTemplate ==================== */}}

{{- /* ==================== toBodyDeletedListChildTemplate ====================
       Recursively detects deleted items within matched list-item pairs
       and appends delete entries to the body.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "StateListExpr" (string) - Go expression for state list
         "PlanListExpr" (string) - Go expression for plan list
         "ParentBodyPath" (string) - Go expression for the parent body path
         "IdAttributes" ([]Attribute) - Attributes used to match items by ID
         "ClassName" (string) - Class name of the parent list item
         "IndexVar" (string) - Loop index variable name
       ========================================================= */}}
{{- define "toBodyDeletedListChildTemplate"}}
{{- $stateListExpr := .StateListExpr}}
{{- $planListExpr := .PlanListExpr}}
{{- $parentBodyPath := .ParentBodyPath}}
{{- $idAttributes := .IdAttributes}}
{{- $parentClassName := .ClassName}}
{{- $indexVar := .IndexVar}}
	for {{$indexVar}} := range {{$stateListExpr}} {
		for p{{$indexVar}} := range {{$planListExpr}} {
			if {{range $i, $a := $idAttributes}}{{if $a.Id}}{{if $i}} && {{end}}{{$stateListExpr}}[{{$indexVar}}].{{toGoName $a.TfName}} == {{$planListExpr}}[p{{$indexVar}}].{{toGoName $a.TfName}}{{end}}{{end}} {
				matchBodyPath{{$indexVar}} := ""
				for mi, mv := range gjson.Get(body.Str, {{$parentBodyPath}}).Array() {
					if mv.Get("{{$parentClassName}}.attributes.rn").String() == {{$stateListExpr}}[{{$indexVar}}].getRn() {
						matchBodyPath{{$indexVar}} = {{$parentBodyPath}} + "." + strconv.Itoa(mi) + ".{{$parentClassName}}.children"
						break
					}
				}
				if matchBodyPath{{$indexVar}} == "" {
					break
				}
				{{- range .Children}}
				{{- if eq .Type "list"}}
				for _, stateChild := range {{$stateListExpr}}[{{$indexVar}}].{{toGoName .TfName}} {
					found := false
					for _, planChild := range {{$planListExpr}}[p{{$indexVar}}].{{toGoName .TfName}} {
						if {{range $i, $a := .Attributes}}{{if $a.Id}}{{if $i}} && {{end}}stateChild.{{toGoName $a.TfName}} == planChild.{{toGoName $a.TfName}}{{end}}{{end}} {
							found = true
							break
						}
					}
					if !found {
						deleteBody := ""
						deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.rn", stateChild.getRn())
						deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.status", "deleted")
						body.Str, _ = sjson.SetRaw(body.Str, matchBodyPath{{$indexVar}}+".-1", deleteBody)
					}
				}
				{{- if .ChildClasses}}
				{{- template "toBodyDeletedListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "%s[%s].%s" $stateListExpr $indexVar (toGoName .TfName)) "PlanListExpr" (printf "%s[p%s].%s" $planListExpr $indexVar (toGoName .TfName)) "ParentBodyPath" (printf "matchBodyPath%s" $indexVar) "IdAttributes" .Attributes "ClassName" .ClassName "IndexVar" (printf "%s_" $indexVar))}}
				{{- end}}
				{{- else if eq .Type "single"}}
				{{- if .ChildClasses}}
				{{- template "toBodyDeletedSingleInListTemplate" (makeMap "Children" .ChildClasses "StateItemExpr" (printf "%s[%s]" $stateListExpr $indexVar) "PlanItemExpr" (printf "%s[p%s]" $planListExpr $indexVar) "ParentBodyPath" (printf "matchBodyPath%s+\".0.%s.children\"" $indexVar .ClassName) "IndexVar" (printf "%s_" $indexVar))}}
				{{- end}}
				{{- end}}
				{{- end}}
				break
			}
		}
	}
{{- end}}
{{- /* ==================== end toBodyDeletedListChildTemplate ==================== */}}

{{- /* ==================== toBodyDeletedChildrenTemplate ====================
       Recursively generates deleted-item body entries for list children.
       Context: map with:
         "Children" ([]YamlConfigChildClass)
         "BodyPath" (string) - Go expression for the body path to the children array
       ========================================================= */}}
{{- define "toBodyDeletedChildrenTemplate"}}
{{- $bodyPath := .BodyPath}}
{{- range .Children}}
{{- if eq .Type "list"}}
	for _, stateChild := range state.{{toGoName .TfName}} {
		found := false
		for _, planChild := range data.{{toGoName .TfName}} {
			if {{range $i, $a := .Attributes}}{{if $a.Id}}{{if $i}} && {{end}}stateChild.{{toGoName $a.TfName}} == planChild.{{toGoName $a.TfName}}{{end}}{{end}} {
				found = true
				break
			}
		}
		if !found {
			deleteBody := ""
			deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.rn", stateChild.getRn())
			deleteBody, _ = sjson.Set(deleteBody, "{{.ClassName}}.attributes.status", "deleted")
			body.Str, _ = sjson.SetRaw(body.Str, {{$bodyPath}}+".-1", deleteBody)
		}
	}
	{{- if .ChildClasses}}
	{{- template "toBodyDeletedListChildTemplate" (makeMap "Children" .ChildClasses "StateListExpr" (printf "state.%s" (toGoName .TfName)) "PlanListExpr" (printf "data.%s" (toGoName .TfName)) "ParentBodyPath" $bodyPath "IdAttributes" .Attributes "ClassName" .ClassName "IndexVar" "di")}}
	{{- end}}
{{- else if eq .Type "single"}}
{{- if .ChildClasses}}
{{- template "toBodyDeletedChildrenTemplate" (makeMap "Children" .ChildClasses "BodyPath" (printf "%s+\".0.%s.children\"" $bodyPath .ClassName))}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- /* ==================== end toBodyDeletedChildrenTemplate ==================== */}}

{{- if hasListChildClasses .ChildClasses}}

func (data {{camelCase .Name}}) toBodyWithDeletes(ctx context.Context, state {{camelCase .Name}}) nxos.Body {
	body := data.toBody()
	bodyPath := data.getClassName() + ".children"
	_ = bodyPath
	{{- template "toBodyDeletedChildrenTemplate" (makeMap "Children" .ChildClasses "BodyPath" "bodyPath")}}
	return body
}
{{- end}}

// End of section. //template:end toDeleteBody

